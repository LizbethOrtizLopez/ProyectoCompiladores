Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> prog
Rule 1     prog -> stmts
Rule 2     stmts -> statement stmts
Rule 3     stmts -> statement
Rule 4     statement -> INTDCL NAME ;
Rule 5     statement -> INTDCL NAME = expression ;
Rule 6     statement -> FLOATDCL NAME ;
Rule 7     statement -> FLOATDCL NAME = expression ;
Rule 8     statement -> BOOLDCL NAME ;
Rule 9     statement -> BOOLDCL NAME = boolexp ;
Rule 10    statement -> WHILE ( boolexp ) { stmts }
Rule 11    statement -> FOR ( statement boolexp ; statement ) { stmts }
Rule 12    statement -> PRINT expression ;
Rule 13    statement -> IF ( boolexp ) { stmts }
Rule 14    statement -> IF ( boolexp ) { stmts } ELSE { stmts }
Rule 15    elifstatement -> ELIF ( boolexp ) { stmts } elifstatement
Rule 16    elifstatement -> ELIF ( boolexp ) { stmts }
Rule 17    statement -> IF ( boolexp ) { stmts } elifstatement ELSE { stmts }
Rule 18    statement -> NAME = expression ;
Rule 19    expression -> ( expression )
Rule 20    expression -> expression + expression
Rule 21    expression -> expression - expression
Rule 22    expression -> expression * expression
Rule 23    expression -> expression / expression
Rule 24    expression -> expression ^ expression
Rule 25    boolexp -> expression GT expression
Rule 26    boolexp -> expression LT expression
Rule 27    boolexp -> expression GE expression
Rule 28    boolexp -> expression LE expression
Rule 29    boolexp -> expression EQ expression
Rule 30    boolexp -> expression NE expression
Rule 31    boolexp -> boolexp AND boolexp
Rule 32    boolexp -> boolexp OR boolexp
Rule 33    expression -> INUMBER
Rule 34    expression -> FNUMBER
Rule 35    expression -> boolexp
Rule 36    boolexp -> BOOLVAL
Rule 37    expression -> NAME

Terminals, with rules where they appear

(                    : 10 11 13 14 15 16 17 19
)                    : 10 11 13 14 15 16 17 19
*                    : 22
+                    : 20
-                    : 21
/                    : 23
;                    : 4 5 6 7 8 9 11 12 18
=                    : 5 7 9 18
AND                  : 31
BOOLDCL              : 8 9
BOOLVAL              : 36
ELIF                 : 15 16
ELSE                 : 14 17
EQ                   : 29
FLOATDCL             : 6 7
FNUMBER              : 34
FOR                  : 11
GE                   : 27
GT                   : 25
IF                   : 13 14 17
INTDCL               : 4 5
INUMBER              : 33
LE                   : 28
LT                   : 26
NAME                 : 4 5 6 7 8 9 18 37
NE                   : 30
OR                   : 32
PRINT                : 12
WHILE                : 10
^                    : 24
error                : 
{                    : 10 11 13 14 14 15 16 17 17
}                    : 10 11 13 14 14 15 16 17 17

Nonterminals, with rules where they appear

boolexp              : 9 10 11 13 14 15 16 17 31 31 32 32 35
elifstatement        : 15 17
expression           : 5 7 12 18 19 20 20 21 21 22 22 23 23 24 24 25 25 26 26 27 27 28 28 29 29 30 30
prog                 : 0
statement            : 2 3 11 11
stmts                : 1 2 10 11 13 14 14 15 16 17 17

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . stmts
    (2) stmts -> . statement stmts
    (3) stmts -> . statement
    (4) statement -> . INTDCL NAME ;
    (5) statement -> . INTDCL NAME = expression ;
    (6) statement -> . FLOATDCL NAME ;
    (7) statement -> . FLOATDCL NAME = expression ;
    (8) statement -> . BOOLDCL NAME ;
    (9) statement -> . BOOLDCL NAME = boolexp ;
    (10) statement -> . WHILE ( boolexp ) { stmts }
    (11) statement -> . FOR ( statement boolexp ; statement ) { stmts }
    (12) statement -> . PRINT expression ;
    (13) statement -> . IF ( boolexp ) { stmts }
    (14) statement -> . IF ( boolexp ) { stmts } ELSE { stmts }
    (17) statement -> . IF ( boolexp ) { stmts } elifstatement ELSE { stmts }
    (18) statement -> . NAME = expression ;

    INTDCL          shift and go to state 4
    FLOATDCL        shift and go to state 6
    BOOLDCL         shift and go to state 7
    WHILE           shift and go to state 8
    FOR             shift and go to state 9
    PRINT           shift and go to state 10
    IF              shift and go to state 11
    NAME            shift and go to state 5

    prog                           shift and go to state 1
    stmts                          shift and go to state 2
    statement                      shift and go to state 3

state 1

    (0) S' -> prog .



state 2

    (1) prog -> stmts .

    $end            reduce using rule 1 (prog -> stmts .)


state 3

    (2) stmts -> statement . stmts
    (3) stmts -> statement .
    (2) stmts -> . statement stmts
    (3) stmts -> . statement
    (4) statement -> . INTDCL NAME ;
    (5) statement -> . INTDCL NAME = expression ;
    (6) statement -> . FLOATDCL NAME ;
    (7) statement -> . FLOATDCL NAME = expression ;
    (8) statement -> . BOOLDCL NAME ;
    (9) statement -> . BOOLDCL NAME = boolexp ;
    (10) statement -> . WHILE ( boolexp ) { stmts }
    (11) statement -> . FOR ( statement boolexp ; statement ) { stmts }
    (12) statement -> . PRINT expression ;
    (13) statement -> . IF ( boolexp ) { stmts }
    (14) statement -> . IF ( boolexp ) { stmts } ELSE { stmts }
    (17) statement -> . IF ( boolexp ) { stmts } elifstatement ELSE { stmts }
    (18) statement -> . NAME = expression ;

    $end            reduce using rule 3 (stmts -> statement .)
    }               reduce using rule 3 (stmts -> statement .)
    INTDCL          shift and go to state 4
    FLOATDCL        shift and go to state 6
    BOOLDCL         shift and go to state 7
    WHILE           shift and go to state 8
    FOR             shift and go to state 9
    PRINT           shift and go to state 10
    IF              shift and go to state 11
    NAME            shift and go to state 5

    statement                      shift and go to state 3
    stmts                          shift and go to state 12

state 4

    (4) statement -> INTDCL . NAME ;
    (5) statement -> INTDCL . NAME = expression ;

    NAME            shift and go to state 13


state 5

    (18) statement -> NAME . = expression ;

    =               shift and go to state 14


state 6

    (6) statement -> FLOATDCL . NAME ;
    (7) statement -> FLOATDCL . NAME = expression ;

    NAME            shift and go to state 15


state 7

    (8) statement -> BOOLDCL . NAME ;
    (9) statement -> BOOLDCL . NAME = boolexp ;

    NAME            shift and go to state 16


state 8

    (10) statement -> WHILE . ( boolexp ) { stmts }

    (               shift and go to state 17


state 9

    (11) statement -> FOR . ( statement boolexp ; statement ) { stmts }

    (               shift and go to state 18


state 10

    (12) statement -> PRINT . expression ;
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL

    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24
    BOOLVAL         shift and go to state 25

    expression                     shift and go to state 19
    boolexp                        shift and go to state 23

state 11

    (13) statement -> IF . ( boolexp ) { stmts }
    (14) statement -> IF . ( boolexp ) { stmts } ELSE { stmts }
    (17) statement -> IF . ( boolexp ) { stmts } elifstatement ELSE { stmts }

    (               shift and go to state 26


state 12

    (2) stmts -> statement stmts .

    $end            reduce using rule 2 (stmts -> statement stmts .)
    }               reduce using rule 2 (stmts -> statement stmts .)


state 13

    (4) statement -> INTDCL NAME . ;
    (5) statement -> INTDCL NAME . = expression ;

    ;               shift and go to state 27
    =               shift and go to state 28


state 14

    (18) statement -> NAME = . expression ;
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL

    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24
    BOOLVAL         shift and go to state 25

    expression                     shift and go to state 29
    boolexp                        shift and go to state 23

state 15

    (6) statement -> FLOATDCL NAME . ;
    (7) statement -> FLOATDCL NAME . = expression ;

    ;               shift and go to state 30
    =               shift and go to state 31


state 16

    (8) statement -> BOOLDCL NAME . ;
    (9) statement -> BOOLDCL NAME . = boolexp ;

    ;               shift and go to state 32
    =               shift and go to state 33


state 17

    (10) statement -> WHILE ( . boolexp ) { stmts }
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME

    BOOLVAL         shift and go to state 25
    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24

    boolexp                        shift and go to state 34
    expression                     shift and go to state 35

state 18

    (11) statement -> FOR ( . statement boolexp ; statement ) { stmts }
    (4) statement -> . INTDCL NAME ;
    (5) statement -> . INTDCL NAME = expression ;
    (6) statement -> . FLOATDCL NAME ;
    (7) statement -> . FLOATDCL NAME = expression ;
    (8) statement -> . BOOLDCL NAME ;
    (9) statement -> . BOOLDCL NAME = boolexp ;
    (10) statement -> . WHILE ( boolexp ) { stmts }
    (11) statement -> . FOR ( statement boolexp ; statement ) { stmts }
    (12) statement -> . PRINT expression ;
    (13) statement -> . IF ( boolexp ) { stmts }
    (14) statement -> . IF ( boolexp ) { stmts } ELSE { stmts }
    (17) statement -> . IF ( boolexp ) { stmts } elifstatement ELSE { stmts }
    (18) statement -> . NAME = expression ;

    INTDCL          shift and go to state 4
    FLOATDCL        shift and go to state 6
    BOOLDCL         shift and go to state 7
    WHILE           shift and go to state 8
    FOR             shift and go to state 9
    PRINT           shift and go to state 10
    IF              shift and go to state 11
    NAME            shift and go to state 5

    statement                      shift and go to state 36

state 19

    (12) statement -> PRINT expression . ;
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression
    (24) expression -> expression . ^ expression
    (25) boolexp -> expression . GT expression
    (26) boolexp -> expression . LT expression
    (27) boolexp -> expression . GE expression
    (28) boolexp -> expression . LE expression
    (29) boolexp -> expression . EQ expression
    (30) boolexp -> expression . NE expression

    ;               shift and go to state 37
    +               shift and go to state 38
    -               shift and go to state 39
    *               shift and go to state 40
    /               shift and go to state 41
    ^               shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    GE              shift and go to state 45
    LE              shift and go to state 46
    EQ              shift and go to state 47
    NE              shift and go to state 48


state 20

    (19) expression -> ( . expression )
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL

    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24
    BOOLVAL         shift and go to state 25

    expression                     shift and go to state 49
    boolexp                        shift and go to state 23

state 21

    (33) expression -> INUMBER .

    ;               reduce using rule 33 (expression -> INUMBER .)
    +               reduce using rule 33 (expression -> INUMBER .)
    -               reduce using rule 33 (expression -> INUMBER .)
    *               reduce using rule 33 (expression -> INUMBER .)
    /               reduce using rule 33 (expression -> INUMBER .)
    ^               reduce using rule 33 (expression -> INUMBER .)
    GT              reduce using rule 33 (expression -> INUMBER .)
    LT              reduce using rule 33 (expression -> INUMBER .)
    GE              reduce using rule 33 (expression -> INUMBER .)
    LE              reduce using rule 33 (expression -> INUMBER .)
    EQ              reduce using rule 33 (expression -> INUMBER .)
    NE              reduce using rule 33 (expression -> INUMBER .)
    )               reduce using rule 33 (expression -> INUMBER .)
    AND             reduce using rule 33 (expression -> INUMBER .)
    OR              reduce using rule 33 (expression -> INUMBER .)


state 22

    (34) expression -> FNUMBER .

    ;               reduce using rule 34 (expression -> FNUMBER .)
    +               reduce using rule 34 (expression -> FNUMBER .)
    -               reduce using rule 34 (expression -> FNUMBER .)
    *               reduce using rule 34 (expression -> FNUMBER .)
    /               reduce using rule 34 (expression -> FNUMBER .)
    ^               reduce using rule 34 (expression -> FNUMBER .)
    GT              reduce using rule 34 (expression -> FNUMBER .)
    LT              reduce using rule 34 (expression -> FNUMBER .)
    GE              reduce using rule 34 (expression -> FNUMBER .)
    LE              reduce using rule 34 (expression -> FNUMBER .)
    EQ              reduce using rule 34 (expression -> FNUMBER .)
    NE              reduce using rule 34 (expression -> FNUMBER .)
    )               reduce using rule 34 (expression -> FNUMBER .)
    AND             reduce using rule 34 (expression -> FNUMBER .)
    OR              reduce using rule 34 (expression -> FNUMBER .)


state 23

    (35) expression -> boolexp .
    (31) boolexp -> boolexp . AND boolexp
    (32) boolexp -> boolexp . OR boolexp

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    ;               reduce using rule 35 (expression -> boolexp .)
    +               reduce using rule 35 (expression -> boolexp .)
    -               reduce using rule 35 (expression -> boolexp .)
    *               reduce using rule 35 (expression -> boolexp .)
    /               reduce using rule 35 (expression -> boolexp .)
    ^               reduce using rule 35 (expression -> boolexp .)
    GT              reduce using rule 35 (expression -> boolexp .)
    LT              reduce using rule 35 (expression -> boolexp .)
    GE              reduce using rule 35 (expression -> boolexp .)
    LE              reduce using rule 35 (expression -> boolexp .)
    EQ              reduce using rule 35 (expression -> boolexp .)
    NE              reduce using rule 35 (expression -> boolexp .)
    )               reduce using rule 35 (expression -> boolexp .)
    AND             shift and go to state 50
    OR              shift and go to state 51

  ! AND             [ reduce using rule 35 (expression -> boolexp .) ]
  ! OR              [ reduce using rule 35 (expression -> boolexp .) ]


state 24

    (37) expression -> NAME .

    ;               reduce using rule 37 (expression -> NAME .)
    +               reduce using rule 37 (expression -> NAME .)
    -               reduce using rule 37 (expression -> NAME .)
    *               reduce using rule 37 (expression -> NAME .)
    /               reduce using rule 37 (expression -> NAME .)
    ^               reduce using rule 37 (expression -> NAME .)
    GT              reduce using rule 37 (expression -> NAME .)
    LT              reduce using rule 37 (expression -> NAME .)
    GE              reduce using rule 37 (expression -> NAME .)
    LE              reduce using rule 37 (expression -> NAME .)
    EQ              reduce using rule 37 (expression -> NAME .)
    NE              reduce using rule 37 (expression -> NAME .)
    )               reduce using rule 37 (expression -> NAME .)
    AND             reduce using rule 37 (expression -> NAME .)
    OR              reduce using rule 37 (expression -> NAME .)


state 25

    (36) boolexp -> BOOLVAL .

    AND             reduce using rule 36 (boolexp -> BOOLVAL .)
    OR              reduce using rule 36 (boolexp -> BOOLVAL .)
    ;               reduce using rule 36 (boolexp -> BOOLVAL .)
    +               reduce using rule 36 (boolexp -> BOOLVAL .)
    -               reduce using rule 36 (boolexp -> BOOLVAL .)
    *               reduce using rule 36 (boolexp -> BOOLVAL .)
    /               reduce using rule 36 (boolexp -> BOOLVAL .)
    ^               reduce using rule 36 (boolexp -> BOOLVAL .)
    GT              reduce using rule 36 (boolexp -> BOOLVAL .)
    LT              reduce using rule 36 (boolexp -> BOOLVAL .)
    GE              reduce using rule 36 (boolexp -> BOOLVAL .)
    LE              reduce using rule 36 (boolexp -> BOOLVAL .)
    EQ              reduce using rule 36 (boolexp -> BOOLVAL .)
    NE              reduce using rule 36 (boolexp -> BOOLVAL .)
    )               reduce using rule 36 (boolexp -> BOOLVAL .)


state 26

    (13) statement -> IF ( . boolexp ) { stmts }
    (14) statement -> IF ( . boolexp ) { stmts } ELSE { stmts }
    (17) statement -> IF ( . boolexp ) { stmts } elifstatement ELSE { stmts }
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME

    BOOLVAL         shift and go to state 25
    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24

    boolexp                        shift and go to state 52
    expression                     shift and go to state 35

state 27

    (4) statement -> INTDCL NAME ; .

    INTDCL          reduce using rule 4 (statement -> INTDCL NAME ; .)
    FLOATDCL        reduce using rule 4 (statement -> INTDCL NAME ; .)
    BOOLDCL         reduce using rule 4 (statement -> INTDCL NAME ; .)
    WHILE           reduce using rule 4 (statement -> INTDCL NAME ; .)
    FOR             reduce using rule 4 (statement -> INTDCL NAME ; .)
    PRINT           reduce using rule 4 (statement -> INTDCL NAME ; .)
    IF              reduce using rule 4 (statement -> INTDCL NAME ; .)
    NAME            reduce using rule 4 (statement -> INTDCL NAME ; .)
    $end            reduce using rule 4 (statement -> INTDCL NAME ; .)
    }               reduce using rule 4 (statement -> INTDCL NAME ; .)
    BOOLVAL         reduce using rule 4 (statement -> INTDCL NAME ; .)
    (               reduce using rule 4 (statement -> INTDCL NAME ; .)
    INUMBER         reduce using rule 4 (statement -> INTDCL NAME ; .)
    FNUMBER         reduce using rule 4 (statement -> INTDCL NAME ; .)
    )               reduce using rule 4 (statement -> INTDCL NAME ; .)


state 28

    (5) statement -> INTDCL NAME = . expression ;
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL

    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24
    BOOLVAL         shift and go to state 25

    expression                     shift and go to state 53
    boolexp                        shift and go to state 23

state 29

    (18) statement -> NAME = expression . ;
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression
    (24) expression -> expression . ^ expression
    (25) boolexp -> expression . GT expression
    (26) boolexp -> expression . LT expression
    (27) boolexp -> expression . GE expression
    (28) boolexp -> expression . LE expression
    (29) boolexp -> expression . EQ expression
    (30) boolexp -> expression . NE expression

    ;               shift and go to state 54
    +               shift and go to state 38
    -               shift and go to state 39
    *               shift and go to state 40
    /               shift and go to state 41
    ^               shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    GE              shift and go to state 45
    LE              shift and go to state 46
    EQ              shift and go to state 47
    NE              shift and go to state 48


state 30

    (6) statement -> FLOATDCL NAME ; .

    INTDCL          reduce using rule 6 (statement -> FLOATDCL NAME ; .)
    FLOATDCL        reduce using rule 6 (statement -> FLOATDCL NAME ; .)
    BOOLDCL         reduce using rule 6 (statement -> FLOATDCL NAME ; .)
    WHILE           reduce using rule 6 (statement -> FLOATDCL NAME ; .)
    FOR             reduce using rule 6 (statement -> FLOATDCL NAME ; .)
    PRINT           reduce using rule 6 (statement -> FLOATDCL NAME ; .)
    IF              reduce using rule 6 (statement -> FLOATDCL NAME ; .)
    NAME            reduce using rule 6 (statement -> FLOATDCL NAME ; .)
    $end            reduce using rule 6 (statement -> FLOATDCL NAME ; .)
    }               reduce using rule 6 (statement -> FLOATDCL NAME ; .)
    BOOLVAL         reduce using rule 6 (statement -> FLOATDCL NAME ; .)
    (               reduce using rule 6 (statement -> FLOATDCL NAME ; .)
    INUMBER         reduce using rule 6 (statement -> FLOATDCL NAME ; .)
    FNUMBER         reduce using rule 6 (statement -> FLOATDCL NAME ; .)
    )               reduce using rule 6 (statement -> FLOATDCL NAME ; .)


state 31

    (7) statement -> FLOATDCL NAME = . expression ;
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL

    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24
    BOOLVAL         shift and go to state 25

    expression                     shift and go to state 55
    boolexp                        shift and go to state 23

state 32

    (8) statement -> BOOLDCL NAME ; .

    INTDCL          reduce using rule 8 (statement -> BOOLDCL NAME ; .)
    FLOATDCL        reduce using rule 8 (statement -> BOOLDCL NAME ; .)
    BOOLDCL         reduce using rule 8 (statement -> BOOLDCL NAME ; .)
    WHILE           reduce using rule 8 (statement -> BOOLDCL NAME ; .)
    FOR             reduce using rule 8 (statement -> BOOLDCL NAME ; .)
    PRINT           reduce using rule 8 (statement -> BOOLDCL NAME ; .)
    IF              reduce using rule 8 (statement -> BOOLDCL NAME ; .)
    NAME            reduce using rule 8 (statement -> BOOLDCL NAME ; .)
    $end            reduce using rule 8 (statement -> BOOLDCL NAME ; .)
    }               reduce using rule 8 (statement -> BOOLDCL NAME ; .)
    BOOLVAL         reduce using rule 8 (statement -> BOOLDCL NAME ; .)
    (               reduce using rule 8 (statement -> BOOLDCL NAME ; .)
    INUMBER         reduce using rule 8 (statement -> BOOLDCL NAME ; .)
    FNUMBER         reduce using rule 8 (statement -> BOOLDCL NAME ; .)
    )               reduce using rule 8 (statement -> BOOLDCL NAME ; .)


state 33

    (9) statement -> BOOLDCL NAME = . boolexp ;
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME

    BOOLVAL         shift and go to state 25
    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24

    boolexp                        shift and go to state 56
    expression                     shift and go to state 35

state 34

    (10) statement -> WHILE ( boolexp . ) { stmts }
    (31) boolexp -> boolexp . AND boolexp
    (32) boolexp -> boolexp . OR boolexp
    (35) expression -> boolexp .

    )               shift and go to state 57
    AND             shift and go to state 50
    OR              shift and go to state 51
    GT              reduce using rule 35 (expression -> boolexp .)
    LT              reduce using rule 35 (expression -> boolexp .)
    GE              reduce using rule 35 (expression -> boolexp .)
    LE              reduce using rule 35 (expression -> boolexp .)
    EQ              reduce using rule 35 (expression -> boolexp .)
    NE              reduce using rule 35 (expression -> boolexp .)
    +               reduce using rule 35 (expression -> boolexp .)
    -               reduce using rule 35 (expression -> boolexp .)
    *               reduce using rule 35 (expression -> boolexp .)
    /               reduce using rule 35 (expression -> boolexp .)
    ^               reduce using rule 35 (expression -> boolexp .)


state 35

    (25) boolexp -> expression . GT expression
    (26) boolexp -> expression . LT expression
    (27) boolexp -> expression . GE expression
    (28) boolexp -> expression . LE expression
    (29) boolexp -> expression . EQ expression
    (30) boolexp -> expression . NE expression
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression
    (24) expression -> expression . ^ expression

    GT              shift and go to state 43
    LT              shift and go to state 44
    GE              shift and go to state 45
    LE              shift and go to state 46
    EQ              shift and go to state 47
    NE              shift and go to state 48
    +               shift and go to state 38
    -               shift and go to state 39
    *               shift and go to state 40
    /               shift and go to state 41
    ^               shift and go to state 42


state 36

    (11) statement -> FOR ( statement . boolexp ; statement ) { stmts }
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME

    BOOLVAL         shift and go to state 25
    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24

    boolexp                        shift and go to state 58
    expression                     shift and go to state 35

state 37

    (12) statement -> PRINT expression ; .

    INTDCL          reduce using rule 12 (statement -> PRINT expression ; .)
    FLOATDCL        reduce using rule 12 (statement -> PRINT expression ; .)
    BOOLDCL         reduce using rule 12 (statement -> PRINT expression ; .)
    WHILE           reduce using rule 12 (statement -> PRINT expression ; .)
    FOR             reduce using rule 12 (statement -> PRINT expression ; .)
    PRINT           reduce using rule 12 (statement -> PRINT expression ; .)
    IF              reduce using rule 12 (statement -> PRINT expression ; .)
    NAME            reduce using rule 12 (statement -> PRINT expression ; .)
    $end            reduce using rule 12 (statement -> PRINT expression ; .)
    }               reduce using rule 12 (statement -> PRINT expression ; .)
    BOOLVAL         reduce using rule 12 (statement -> PRINT expression ; .)
    (               reduce using rule 12 (statement -> PRINT expression ; .)
    INUMBER         reduce using rule 12 (statement -> PRINT expression ; .)
    FNUMBER         reduce using rule 12 (statement -> PRINT expression ; .)
    )               reduce using rule 12 (statement -> PRINT expression ; .)


state 38

    (20) expression -> expression + . expression
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL

    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24
    BOOLVAL         shift and go to state 25

    expression                     shift and go to state 59
    boolexp                        shift and go to state 23

state 39

    (21) expression -> expression - . expression
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL

    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24
    BOOLVAL         shift and go to state 25

    expression                     shift and go to state 60
    boolexp                        shift and go to state 23

state 40

    (22) expression -> expression * . expression
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL

    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24
    BOOLVAL         shift and go to state 25

    expression                     shift and go to state 61
    boolexp                        shift and go to state 23

state 41

    (23) expression -> expression / . expression
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL

    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24
    BOOLVAL         shift and go to state 25

    expression                     shift and go to state 62
    boolexp                        shift and go to state 23

state 42

    (24) expression -> expression ^ . expression
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL

    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24
    BOOLVAL         shift and go to state 25

    expression                     shift and go to state 63
    boolexp                        shift and go to state 23

state 43

    (25) boolexp -> expression GT . expression
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL

    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24
    BOOLVAL         shift and go to state 25

    expression                     shift and go to state 64
    boolexp                        shift and go to state 23

state 44

    (26) boolexp -> expression LT . expression
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL

    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24
    BOOLVAL         shift and go to state 25

    expression                     shift and go to state 65
    boolexp                        shift and go to state 23

state 45

    (27) boolexp -> expression GE . expression
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL

    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24
    BOOLVAL         shift and go to state 25

    expression                     shift and go to state 66
    boolexp                        shift and go to state 23

state 46

    (28) boolexp -> expression LE . expression
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL

    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24
    BOOLVAL         shift and go to state 25

    expression                     shift and go to state 67
    boolexp                        shift and go to state 23

state 47

    (29) boolexp -> expression EQ . expression
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL

    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24
    BOOLVAL         shift and go to state 25

    expression                     shift and go to state 68
    boolexp                        shift and go to state 23

state 48

    (30) boolexp -> expression NE . expression
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL

    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24
    BOOLVAL         shift and go to state 25

    expression                     shift and go to state 69
    boolexp                        shift and go to state 23

state 49

    (19) expression -> ( expression . )
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression
    (24) expression -> expression . ^ expression
    (25) boolexp -> expression . GT expression
    (26) boolexp -> expression . LT expression
    (27) boolexp -> expression . GE expression
    (28) boolexp -> expression . LE expression
    (29) boolexp -> expression . EQ expression
    (30) boolexp -> expression . NE expression

    )               shift and go to state 70
    +               shift and go to state 38
    -               shift and go to state 39
    *               shift and go to state 40
    /               shift and go to state 41
    ^               shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    GE              shift and go to state 45
    LE              shift and go to state 46
    EQ              shift and go to state 47
    NE              shift and go to state 48


state 50

    (31) boolexp -> boolexp AND . boolexp
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME

    BOOLVAL         shift and go to state 25
    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24

    boolexp                        shift and go to state 71
    expression                     shift and go to state 35

state 51

    (32) boolexp -> boolexp OR . boolexp
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME

    BOOLVAL         shift and go to state 25
    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24

    boolexp                        shift and go to state 72
    expression                     shift and go to state 35

state 52

    (13) statement -> IF ( boolexp . ) { stmts }
    (14) statement -> IF ( boolexp . ) { stmts } ELSE { stmts }
    (17) statement -> IF ( boolexp . ) { stmts } elifstatement ELSE { stmts }
    (31) boolexp -> boolexp . AND boolexp
    (32) boolexp -> boolexp . OR boolexp
    (35) expression -> boolexp .

    )               shift and go to state 73
    AND             shift and go to state 50
    OR              shift and go to state 51
    GT              reduce using rule 35 (expression -> boolexp .)
    LT              reduce using rule 35 (expression -> boolexp .)
    GE              reduce using rule 35 (expression -> boolexp .)
    LE              reduce using rule 35 (expression -> boolexp .)
    EQ              reduce using rule 35 (expression -> boolexp .)
    NE              reduce using rule 35 (expression -> boolexp .)
    +               reduce using rule 35 (expression -> boolexp .)
    -               reduce using rule 35 (expression -> boolexp .)
    *               reduce using rule 35 (expression -> boolexp .)
    /               reduce using rule 35 (expression -> boolexp .)
    ^               reduce using rule 35 (expression -> boolexp .)


state 53

    (5) statement -> INTDCL NAME = expression . ;
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression
    (24) expression -> expression . ^ expression
    (25) boolexp -> expression . GT expression
    (26) boolexp -> expression . LT expression
    (27) boolexp -> expression . GE expression
    (28) boolexp -> expression . LE expression
    (29) boolexp -> expression . EQ expression
    (30) boolexp -> expression . NE expression

    ;               shift and go to state 74
    +               shift and go to state 38
    -               shift and go to state 39
    *               shift and go to state 40
    /               shift and go to state 41
    ^               shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    GE              shift and go to state 45
    LE              shift and go to state 46
    EQ              shift and go to state 47
    NE              shift and go to state 48


state 54

    (18) statement -> NAME = expression ; .

    INTDCL          reduce using rule 18 (statement -> NAME = expression ; .)
    FLOATDCL        reduce using rule 18 (statement -> NAME = expression ; .)
    BOOLDCL         reduce using rule 18 (statement -> NAME = expression ; .)
    WHILE           reduce using rule 18 (statement -> NAME = expression ; .)
    FOR             reduce using rule 18 (statement -> NAME = expression ; .)
    PRINT           reduce using rule 18 (statement -> NAME = expression ; .)
    IF              reduce using rule 18 (statement -> NAME = expression ; .)
    NAME            reduce using rule 18 (statement -> NAME = expression ; .)
    $end            reduce using rule 18 (statement -> NAME = expression ; .)
    }               reduce using rule 18 (statement -> NAME = expression ; .)
    BOOLVAL         reduce using rule 18 (statement -> NAME = expression ; .)
    (               reduce using rule 18 (statement -> NAME = expression ; .)
    INUMBER         reduce using rule 18 (statement -> NAME = expression ; .)
    FNUMBER         reduce using rule 18 (statement -> NAME = expression ; .)
    )               reduce using rule 18 (statement -> NAME = expression ; .)


state 55

    (7) statement -> FLOATDCL NAME = expression . ;
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression
    (24) expression -> expression . ^ expression
    (25) boolexp -> expression . GT expression
    (26) boolexp -> expression . LT expression
    (27) boolexp -> expression . GE expression
    (28) boolexp -> expression . LE expression
    (29) boolexp -> expression . EQ expression
    (30) boolexp -> expression . NE expression

    ;               shift and go to state 75
    +               shift and go to state 38
    -               shift and go to state 39
    *               shift and go to state 40
    /               shift and go to state 41
    ^               shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    GE              shift and go to state 45
    LE              shift and go to state 46
    EQ              shift and go to state 47
    NE              shift and go to state 48


state 56

    (9) statement -> BOOLDCL NAME = boolexp . ;
    (31) boolexp -> boolexp . AND boolexp
    (32) boolexp -> boolexp . OR boolexp
    (35) expression -> boolexp .

    ;               shift and go to state 76
    AND             shift and go to state 50
    OR              shift and go to state 51
    GT              reduce using rule 35 (expression -> boolexp .)
    LT              reduce using rule 35 (expression -> boolexp .)
    GE              reduce using rule 35 (expression -> boolexp .)
    LE              reduce using rule 35 (expression -> boolexp .)
    EQ              reduce using rule 35 (expression -> boolexp .)
    NE              reduce using rule 35 (expression -> boolexp .)
    +               reduce using rule 35 (expression -> boolexp .)
    -               reduce using rule 35 (expression -> boolexp .)
    *               reduce using rule 35 (expression -> boolexp .)
    /               reduce using rule 35 (expression -> boolexp .)
    ^               reduce using rule 35 (expression -> boolexp .)


state 57

    (10) statement -> WHILE ( boolexp ) . { stmts }

    {               shift and go to state 77


state 58

    (11) statement -> FOR ( statement boolexp . ; statement ) { stmts }
    (31) boolexp -> boolexp . AND boolexp
    (32) boolexp -> boolexp . OR boolexp
    (35) expression -> boolexp .

    ;               shift and go to state 78
    AND             shift and go to state 50
    OR              shift and go to state 51
    GT              reduce using rule 35 (expression -> boolexp .)
    LT              reduce using rule 35 (expression -> boolexp .)
    GE              reduce using rule 35 (expression -> boolexp .)
    LE              reduce using rule 35 (expression -> boolexp .)
    EQ              reduce using rule 35 (expression -> boolexp .)
    NE              reduce using rule 35 (expression -> boolexp .)
    +               reduce using rule 35 (expression -> boolexp .)
    -               reduce using rule 35 (expression -> boolexp .)
    *               reduce using rule 35 (expression -> boolexp .)
    /               reduce using rule 35 (expression -> boolexp .)
    ^               reduce using rule 35 (expression -> boolexp .)


state 59

    (20) expression -> expression + expression .
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression
    (24) expression -> expression . ^ expression
    (25) boolexp -> expression . GT expression
    (26) boolexp -> expression . LT expression
    (27) boolexp -> expression . GE expression
    (28) boolexp -> expression . LE expression
    (29) boolexp -> expression . EQ expression
    (30) boolexp -> expression . NE expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    ;               reduce using rule 20 (expression -> expression + expression .)
    )               reduce using rule 20 (expression -> expression + expression .)
    AND             reduce using rule 20 (expression -> expression + expression .)
    OR              reduce using rule 20 (expression -> expression + expression .)
    +               shift and go to state 38
    -               shift and go to state 39
    *               shift and go to state 40
    /               shift and go to state 41
    ^               shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    GE              shift and go to state 45
    LE              shift and go to state 46
    EQ              shift and go to state 47
    NE              shift and go to state 48

  ! +               [ reduce using rule 20 (expression -> expression + expression .) ]
  ! -               [ reduce using rule 20 (expression -> expression + expression .) ]
  ! *               [ reduce using rule 20 (expression -> expression + expression .) ]
  ! /               [ reduce using rule 20 (expression -> expression + expression .) ]
  ! ^               [ reduce using rule 20 (expression -> expression + expression .) ]
  ! GT              [ reduce using rule 20 (expression -> expression + expression .) ]
  ! LT              [ reduce using rule 20 (expression -> expression + expression .) ]
  ! GE              [ reduce using rule 20 (expression -> expression + expression .) ]
  ! LE              [ reduce using rule 20 (expression -> expression + expression .) ]
  ! EQ              [ reduce using rule 20 (expression -> expression + expression .) ]
  ! NE              [ reduce using rule 20 (expression -> expression + expression .) ]


state 60

    (21) expression -> expression - expression .
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression
    (24) expression -> expression . ^ expression
    (25) boolexp -> expression . GT expression
    (26) boolexp -> expression . LT expression
    (27) boolexp -> expression . GE expression
    (28) boolexp -> expression . LE expression
    (29) boolexp -> expression . EQ expression
    (30) boolexp -> expression . NE expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    ;               reduce using rule 21 (expression -> expression - expression .)
    )               reduce using rule 21 (expression -> expression - expression .)
    AND             reduce using rule 21 (expression -> expression - expression .)
    OR              reduce using rule 21 (expression -> expression - expression .)
    +               shift and go to state 38
    -               shift and go to state 39
    *               shift and go to state 40
    /               shift and go to state 41
    ^               shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    GE              shift and go to state 45
    LE              shift and go to state 46
    EQ              shift and go to state 47
    NE              shift and go to state 48

  ! +               [ reduce using rule 21 (expression -> expression - expression .) ]
  ! -               [ reduce using rule 21 (expression -> expression - expression .) ]
  ! *               [ reduce using rule 21 (expression -> expression - expression .) ]
  ! /               [ reduce using rule 21 (expression -> expression - expression .) ]
  ! ^               [ reduce using rule 21 (expression -> expression - expression .) ]
  ! GT              [ reduce using rule 21 (expression -> expression - expression .) ]
  ! LT              [ reduce using rule 21 (expression -> expression - expression .) ]
  ! GE              [ reduce using rule 21 (expression -> expression - expression .) ]
  ! LE              [ reduce using rule 21 (expression -> expression - expression .) ]
  ! EQ              [ reduce using rule 21 (expression -> expression - expression .) ]
  ! NE              [ reduce using rule 21 (expression -> expression - expression .) ]


state 61

    (22) expression -> expression * expression .
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression
    (24) expression -> expression . ^ expression
    (25) boolexp -> expression . GT expression
    (26) boolexp -> expression . LT expression
    (27) boolexp -> expression . GE expression
    (28) boolexp -> expression . LE expression
    (29) boolexp -> expression . EQ expression
    (30) boolexp -> expression . NE expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    ;               reduce using rule 22 (expression -> expression * expression .)
    )               reduce using rule 22 (expression -> expression * expression .)
    AND             reduce using rule 22 (expression -> expression * expression .)
    OR              reduce using rule 22 (expression -> expression * expression .)
    +               shift and go to state 38
    -               shift and go to state 39
    *               shift and go to state 40
    /               shift and go to state 41
    ^               shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    GE              shift and go to state 45
    LE              shift and go to state 46
    EQ              shift and go to state 47
    NE              shift and go to state 48

  ! +               [ reduce using rule 22 (expression -> expression * expression .) ]
  ! -               [ reduce using rule 22 (expression -> expression * expression .) ]
  ! *               [ reduce using rule 22 (expression -> expression * expression .) ]
  ! /               [ reduce using rule 22 (expression -> expression * expression .) ]
  ! ^               [ reduce using rule 22 (expression -> expression * expression .) ]
  ! GT              [ reduce using rule 22 (expression -> expression * expression .) ]
  ! LT              [ reduce using rule 22 (expression -> expression * expression .) ]
  ! GE              [ reduce using rule 22 (expression -> expression * expression .) ]
  ! LE              [ reduce using rule 22 (expression -> expression * expression .) ]
  ! EQ              [ reduce using rule 22 (expression -> expression * expression .) ]
  ! NE              [ reduce using rule 22 (expression -> expression * expression .) ]


state 62

    (23) expression -> expression / expression .
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression
    (24) expression -> expression . ^ expression
    (25) boolexp -> expression . GT expression
    (26) boolexp -> expression . LT expression
    (27) boolexp -> expression . GE expression
    (28) boolexp -> expression . LE expression
    (29) boolexp -> expression . EQ expression
    (30) boolexp -> expression . NE expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    ;               reduce using rule 23 (expression -> expression / expression .)
    )               reduce using rule 23 (expression -> expression / expression .)
    AND             reduce using rule 23 (expression -> expression / expression .)
    OR              reduce using rule 23 (expression -> expression / expression .)
    +               shift and go to state 38
    -               shift and go to state 39
    *               shift and go to state 40
    /               shift and go to state 41
    ^               shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    GE              shift and go to state 45
    LE              shift and go to state 46
    EQ              shift and go to state 47
    NE              shift and go to state 48

  ! +               [ reduce using rule 23 (expression -> expression / expression .) ]
  ! -               [ reduce using rule 23 (expression -> expression / expression .) ]
  ! *               [ reduce using rule 23 (expression -> expression / expression .) ]
  ! /               [ reduce using rule 23 (expression -> expression / expression .) ]
  ! ^               [ reduce using rule 23 (expression -> expression / expression .) ]
  ! GT              [ reduce using rule 23 (expression -> expression / expression .) ]
  ! LT              [ reduce using rule 23 (expression -> expression / expression .) ]
  ! GE              [ reduce using rule 23 (expression -> expression / expression .) ]
  ! LE              [ reduce using rule 23 (expression -> expression / expression .) ]
  ! EQ              [ reduce using rule 23 (expression -> expression / expression .) ]
  ! NE              [ reduce using rule 23 (expression -> expression / expression .) ]


state 63

    (24) expression -> expression ^ expression .
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression
    (24) expression -> expression . ^ expression
    (25) boolexp -> expression . GT expression
    (26) boolexp -> expression . LT expression
    (27) boolexp -> expression . GE expression
    (28) boolexp -> expression . LE expression
    (29) boolexp -> expression . EQ expression
    (30) boolexp -> expression . NE expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    ;               reduce using rule 24 (expression -> expression ^ expression .)
    )               reduce using rule 24 (expression -> expression ^ expression .)
    AND             reduce using rule 24 (expression -> expression ^ expression .)
    OR              reduce using rule 24 (expression -> expression ^ expression .)
    +               shift and go to state 38
    -               shift and go to state 39
    *               shift and go to state 40
    /               shift and go to state 41
    ^               shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    GE              shift and go to state 45
    LE              shift and go to state 46
    EQ              shift and go to state 47
    NE              shift and go to state 48

  ! +               [ reduce using rule 24 (expression -> expression ^ expression .) ]
  ! -               [ reduce using rule 24 (expression -> expression ^ expression .) ]
  ! *               [ reduce using rule 24 (expression -> expression ^ expression .) ]
  ! /               [ reduce using rule 24 (expression -> expression ^ expression .) ]
  ! ^               [ reduce using rule 24 (expression -> expression ^ expression .) ]
  ! GT              [ reduce using rule 24 (expression -> expression ^ expression .) ]
  ! LT              [ reduce using rule 24 (expression -> expression ^ expression .) ]
  ! GE              [ reduce using rule 24 (expression -> expression ^ expression .) ]
  ! LE              [ reduce using rule 24 (expression -> expression ^ expression .) ]
  ! EQ              [ reduce using rule 24 (expression -> expression ^ expression .) ]
  ! NE              [ reduce using rule 24 (expression -> expression ^ expression .) ]


state 64

    (25) boolexp -> expression GT expression .
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression
    (24) expression -> expression . ^ expression
    (25) boolexp -> expression . GT expression
    (26) boolexp -> expression . LT expression
    (27) boolexp -> expression . GE expression
    (28) boolexp -> expression . LE expression
    (29) boolexp -> expression . EQ expression
    (30) boolexp -> expression . NE expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    AND             reduce using rule 25 (boolexp -> expression GT expression .)
    OR              reduce using rule 25 (boolexp -> expression GT expression .)
    ;               reduce using rule 25 (boolexp -> expression GT expression .)
    )               reduce using rule 25 (boolexp -> expression GT expression .)
    +               shift and go to state 38
    -               shift and go to state 39
    *               shift and go to state 40
    /               shift and go to state 41
    ^               shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    GE              shift and go to state 45
    LE              shift and go to state 46
    EQ              shift and go to state 47
    NE              shift and go to state 48

  ! +               [ reduce using rule 25 (boolexp -> expression GT expression .) ]
  ! -               [ reduce using rule 25 (boolexp -> expression GT expression .) ]
  ! *               [ reduce using rule 25 (boolexp -> expression GT expression .) ]
  ! /               [ reduce using rule 25 (boolexp -> expression GT expression .) ]
  ! ^               [ reduce using rule 25 (boolexp -> expression GT expression .) ]
  ! GT              [ reduce using rule 25 (boolexp -> expression GT expression .) ]
  ! LT              [ reduce using rule 25 (boolexp -> expression GT expression .) ]
  ! GE              [ reduce using rule 25 (boolexp -> expression GT expression .) ]
  ! LE              [ reduce using rule 25 (boolexp -> expression GT expression .) ]
  ! EQ              [ reduce using rule 25 (boolexp -> expression GT expression .) ]
  ! NE              [ reduce using rule 25 (boolexp -> expression GT expression .) ]


state 65

    (26) boolexp -> expression LT expression .
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression
    (24) expression -> expression . ^ expression
    (25) boolexp -> expression . GT expression
    (26) boolexp -> expression . LT expression
    (27) boolexp -> expression . GE expression
    (28) boolexp -> expression . LE expression
    (29) boolexp -> expression . EQ expression
    (30) boolexp -> expression . NE expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    AND             reduce using rule 26 (boolexp -> expression LT expression .)
    OR              reduce using rule 26 (boolexp -> expression LT expression .)
    ;               reduce using rule 26 (boolexp -> expression LT expression .)
    )               reduce using rule 26 (boolexp -> expression LT expression .)
    +               shift and go to state 38
    -               shift and go to state 39
    *               shift and go to state 40
    /               shift and go to state 41
    ^               shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    GE              shift and go to state 45
    LE              shift and go to state 46
    EQ              shift and go to state 47
    NE              shift and go to state 48

  ! +               [ reduce using rule 26 (boolexp -> expression LT expression .) ]
  ! -               [ reduce using rule 26 (boolexp -> expression LT expression .) ]
  ! *               [ reduce using rule 26 (boolexp -> expression LT expression .) ]
  ! /               [ reduce using rule 26 (boolexp -> expression LT expression .) ]
  ! ^               [ reduce using rule 26 (boolexp -> expression LT expression .) ]
  ! GT              [ reduce using rule 26 (boolexp -> expression LT expression .) ]
  ! LT              [ reduce using rule 26 (boolexp -> expression LT expression .) ]
  ! GE              [ reduce using rule 26 (boolexp -> expression LT expression .) ]
  ! LE              [ reduce using rule 26 (boolexp -> expression LT expression .) ]
  ! EQ              [ reduce using rule 26 (boolexp -> expression LT expression .) ]
  ! NE              [ reduce using rule 26 (boolexp -> expression LT expression .) ]


state 66

    (27) boolexp -> expression GE expression .
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression
    (24) expression -> expression . ^ expression
    (25) boolexp -> expression . GT expression
    (26) boolexp -> expression . LT expression
    (27) boolexp -> expression . GE expression
    (28) boolexp -> expression . LE expression
    (29) boolexp -> expression . EQ expression
    (30) boolexp -> expression . NE expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    AND             reduce using rule 27 (boolexp -> expression GE expression .)
    OR              reduce using rule 27 (boolexp -> expression GE expression .)
    ;               reduce using rule 27 (boolexp -> expression GE expression .)
    )               reduce using rule 27 (boolexp -> expression GE expression .)
    +               shift and go to state 38
    -               shift and go to state 39
    *               shift and go to state 40
    /               shift and go to state 41
    ^               shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    GE              shift and go to state 45
    LE              shift and go to state 46
    EQ              shift and go to state 47
    NE              shift and go to state 48

  ! +               [ reduce using rule 27 (boolexp -> expression GE expression .) ]
  ! -               [ reduce using rule 27 (boolexp -> expression GE expression .) ]
  ! *               [ reduce using rule 27 (boolexp -> expression GE expression .) ]
  ! /               [ reduce using rule 27 (boolexp -> expression GE expression .) ]
  ! ^               [ reduce using rule 27 (boolexp -> expression GE expression .) ]
  ! GT              [ reduce using rule 27 (boolexp -> expression GE expression .) ]
  ! LT              [ reduce using rule 27 (boolexp -> expression GE expression .) ]
  ! GE              [ reduce using rule 27 (boolexp -> expression GE expression .) ]
  ! LE              [ reduce using rule 27 (boolexp -> expression GE expression .) ]
  ! EQ              [ reduce using rule 27 (boolexp -> expression GE expression .) ]
  ! NE              [ reduce using rule 27 (boolexp -> expression GE expression .) ]


state 67

    (28) boolexp -> expression LE expression .
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression
    (24) expression -> expression . ^ expression
    (25) boolexp -> expression . GT expression
    (26) boolexp -> expression . LT expression
    (27) boolexp -> expression . GE expression
    (28) boolexp -> expression . LE expression
    (29) boolexp -> expression . EQ expression
    (30) boolexp -> expression . NE expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    AND             reduce using rule 28 (boolexp -> expression LE expression .)
    OR              reduce using rule 28 (boolexp -> expression LE expression .)
    ;               reduce using rule 28 (boolexp -> expression LE expression .)
    )               reduce using rule 28 (boolexp -> expression LE expression .)
    +               shift and go to state 38
    -               shift and go to state 39
    *               shift and go to state 40
    /               shift and go to state 41
    ^               shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    GE              shift and go to state 45
    LE              shift and go to state 46
    EQ              shift and go to state 47
    NE              shift and go to state 48

  ! +               [ reduce using rule 28 (boolexp -> expression LE expression .) ]
  ! -               [ reduce using rule 28 (boolexp -> expression LE expression .) ]
  ! *               [ reduce using rule 28 (boolexp -> expression LE expression .) ]
  ! /               [ reduce using rule 28 (boolexp -> expression LE expression .) ]
  ! ^               [ reduce using rule 28 (boolexp -> expression LE expression .) ]
  ! GT              [ reduce using rule 28 (boolexp -> expression LE expression .) ]
  ! LT              [ reduce using rule 28 (boolexp -> expression LE expression .) ]
  ! GE              [ reduce using rule 28 (boolexp -> expression LE expression .) ]
  ! LE              [ reduce using rule 28 (boolexp -> expression LE expression .) ]
  ! EQ              [ reduce using rule 28 (boolexp -> expression LE expression .) ]
  ! NE              [ reduce using rule 28 (boolexp -> expression LE expression .) ]


state 68

    (29) boolexp -> expression EQ expression .
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression
    (24) expression -> expression . ^ expression
    (25) boolexp -> expression . GT expression
    (26) boolexp -> expression . LT expression
    (27) boolexp -> expression . GE expression
    (28) boolexp -> expression . LE expression
    (29) boolexp -> expression . EQ expression
    (30) boolexp -> expression . NE expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    AND             reduce using rule 29 (boolexp -> expression EQ expression .)
    OR              reduce using rule 29 (boolexp -> expression EQ expression .)
    ;               reduce using rule 29 (boolexp -> expression EQ expression .)
    )               reduce using rule 29 (boolexp -> expression EQ expression .)
    +               shift and go to state 38
    -               shift and go to state 39
    *               shift and go to state 40
    /               shift and go to state 41
    ^               shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    GE              shift and go to state 45
    LE              shift and go to state 46
    EQ              shift and go to state 47
    NE              shift and go to state 48

  ! +               [ reduce using rule 29 (boolexp -> expression EQ expression .) ]
  ! -               [ reduce using rule 29 (boolexp -> expression EQ expression .) ]
  ! *               [ reduce using rule 29 (boolexp -> expression EQ expression .) ]
  ! /               [ reduce using rule 29 (boolexp -> expression EQ expression .) ]
  ! ^               [ reduce using rule 29 (boolexp -> expression EQ expression .) ]
  ! GT              [ reduce using rule 29 (boolexp -> expression EQ expression .) ]
  ! LT              [ reduce using rule 29 (boolexp -> expression EQ expression .) ]
  ! GE              [ reduce using rule 29 (boolexp -> expression EQ expression .) ]
  ! LE              [ reduce using rule 29 (boolexp -> expression EQ expression .) ]
  ! EQ              [ reduce using rule 29 (boolexp -> expression EQ expression .) ]
  ! NE              [ reduce using rule 29 (boolexp -> expression EQ expression .) ]


state 69

    (30) boolexp -> expression NE expression .
    (20) expression -> expression . + expression
    (21) expression -> expression . - expression
    (22) expression -> expression . * expression
    (23) expression -> expression . / expression
    (24) expression -> expression . ^ expression
    (25) boolexp -> expression . GT expression
    (26) boolexp -> expression . LT expression
    (27) boolexp -> expression . GE expression
    (28) boolexp -> expression . LE expression
    (29) boolexp -> expression . EQ expression
    (30) boolexp -> expression . NE expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
    AND             reduce using rule 30 (boolexp -> expression NE expression .)
    OR              reduce using rule 30 (boolexp -> expression NE expression .)
    ;               reduce using rule 30 (boolexp -> expression NE expression .)
    )               reduce using rule 30 (boolexp -> expression NE expression .)
    +               shift and go to state 38
    -               shift and go to state 39
    *               shift and go to state 40
    /               shift and go to state 41
    ^               shift and go to state 42
    GT              shift and go to state 43
    LT              shift and go to state 44
    GE              shift and go to state 45
    LE              shift and go to state 46
    EQ              shift and go to state 47
    NE              shift and go to state 48

  ! +               [ reduce using rule 30 (boolexp -> expression NE expression .) ]
  ! -               [ reduce using rule 30 (boolexp -> expression NE expression .) ]
  ! *               [ reduce using rule 30 (boolexp -> expression NE expression .) ]
  ! /               [ reduce using rule 30 (boolexp -> expression NE expression .) ]
  ! ^               [ reduce using rule 30 (boolexp -> expression NE expression .) ]
  ! GT              [ reduce using rule 30 (boolexp -> expression NE expression .) ]
  ! LT              [ reduce using rule 30 (boolexp -> expression NE expression .) ]
  ! GE              [ reduce using rule 30 (boolexp -> expression NE expression .) ]
  ! LE              [ reduce using rule 30 (boolexp -> expression NE expression .) ]
  ! EQ              [ reduce using rule 30 (boolexp -> expression NE expression .) ]
  ! NE              [ reduce using rule 30 (boolexp -> expression NE expression .) ]


state 70

    (19) expression -> ( expression ) .

    ;               reduce using rule 19 (expression -> ( expression ) .)
    +               reduce using rule 19 (expression -> ( expression ) .)
    -               reduce using rule 19 (expression -> ( expression ) .)
    *               reduce using rule 19 (expression -> ( expression ) .)
    /               reduce using rule 19 (expression -> ( expression ) .)
    ^               reduce using rule 19 (expression -> ( expression ) .)
    GT              reduce using rule 19 (expression -> ( expression ) .)
    LT              reduce using rule 19 (expression -> ( expression ) .)
    GE              reduce using rule 19 (expression -> ( expression ) .)
    LE              reduce using rule 19 (expression -> ( expression ) .)
    EQ              reduce using rule 19 (expression -> ( expression ) .)
    NE              reduce using rule 19 (expression -> ( expression ) .)
    )               reduce using rule 19 (expression -> ( expression ) .)
    AND             reduce using rule 19 (expression -> ( expression ) .)
    OR              reduce using rule 19 (expression -> ( expression ) .)


state 71

    (31) boolexp -> boolexp AND boolexp .
    (31) boolexp -> boolexp . AND boolexp
    (32) boolexp -> boolexp . OR boolexp
    (35) expression -> boolexp .

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for GT resolved using rule 31 (boolexp -> boolexp AND boolexp .)
  ! reduce/reduce conflict for LT resolved using rule 31 (boolexp -> boolexp AND boolexp .)
  ! reduce/reduce conflict for GE resolved using rule 31 (boolexp -> boolexp AND boolexp .)
  ! reduce/reduce conflict for LE resolved using rule 31 (boolexp -> boolexp AND boolexp .)
  ! reduce/reduce conflict for EQ resolved using rule 31 (boolexp -> boolexp AND boolexp .)
  ! reduce/reduce conflict for NE resolved using rule 31 (boolexp -> boolexp AND boolexp .)
  ! reduce/reduce conflict for + resolved using rule 31 (boolexp -> boolexp AND boolexp .)
  ! reduce/reduce conflict for - resolved using rule 31 (boolexp -> boolexp AND boolexp .)
  ! reduce/reduce conflict for * resolved using rule 31 (boolexp -> boolexp AND boolexp .)
  ! reduce/reduce conflict for / resolved using rule 31 (boolexp -> boolexp AND boolexp .)
  ! reduce/reduce conflict for ^ resolved using rule 31 (boolexp -> boolexp AND boolexp .)
    ;               reduce using rule 31 (boolexp -> boolexp AND boolexp .)
    +               reduce using rule 31 (boolexp -> boolexp AND boolexp .)
    -               reduce using rule 31 (boolexp -> boolexp AND boolexp .)
    *               reduce using rule 31 (boolexp -> boolexp AND boolexp .)
    /               reduce using rule 31 (boolexp -> boolexp AND boolexp .)
    ^               reduce using rule 31 (boolexp -> boolexp AND boolexp .)
    GT              reduce using rule 31 (boolexp -> boolexp AND boolexp .)
    LT              reduce using rule 31 (boolexp -> boolexp AND boolexp .)
    GE              reduce using rule 31 (boolexp -> boolexp AND boolexp .)
    LE              reduce using rule 31 (boolexp -> boolexp AND boolexp .)
    EQ              reduce using rule 31 (boolexp -> boolexp AND boolexp .)
    NE              reduce using rule 31 (boolexp -> boolexp AND boolexp .)
    )               reduce using rule 31 (boolexp -> boolexp AND boolexp .)
    AND             shift and go to state 50
    OR              shift and go to state 51

  ! AND             [ reduce using rule 31 (boolexp -> boolexp AND boolexp .) ]
  ! OR              [ reduce using rule 31 (boolexp -> boolexp AND boolexp .) ]
  ! GT              [ reduce using rule 35 (expression -> boolexp .) ]
  ! LT              [ reduce using rule 35 (expression -> boolexp .) ]
  ! GE              [ reduce using rule 35 (expression -> boolexp .) ]
  ! LE              [ reduce using rule 35 (expression -> boolexp .) ]
  ! EQ              [ reduce using rule 35 (expression -> boolexp .) ]
  ! NE              [ reduce using rule 35 (expression -> boolexp .) ]
  ! +               [ reduce using rule 35 (expression -> boolexp .) ]
  ! -               [ reduce using rule 35 (expression -> boolexp .) ]
  ! *               [ reduce using rule 35 (expression -> boolexp .) ]
  ! /               [ reduce using rule 35 (expression -> boolexp .) ]
  ! ^               [ reduce using rule 35 (expression -> boolexp .) ]


state 72

    (32) boolexp -> boolexp OR boolexp .
    (31) boolexp -> boolexp . AND boolexp
    (32) boolexp -> boolexp . OR boolexp
    (35) expression -> boolexp .

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for GT resolved using rule 32 (boolexp -> boolexp OR boolexp .)
  ! reduce/reduce conflict for LT resolved using rule 32 (boolexp -> boolexp OR boolexp .)
  ! reduce/reduce conflict for GE resolved using rule 32 (boolexp -> boolexp OR boolexp .)
  ! reduce/reduce conflict for LE resolved using rule 32 (boolexp -> boolexp OR boolexp .)
  ! reduce/reduce conflict for EQ resolved using rule 32 (boolexp -> boolexp OR boolexp .)
  ! reduce/reduce conflict for NE resolved using rule 32 (boolexp -> boolexp OR boolexp .)
  ! reduce/reduce conflict for + resolved using rule 32 (boolexp -> boolexp OR boolexp .)
  ! reduce/reduce conflict for - resolved using rule 32 (boolexp -> boolexp OR boolexp .)
  ! reduce/reduce conflict for * resolved using rule 32 (boolexp -> boolexp OR boolexp .)
  ! reduce/reduce conflict for / resolved using rule 32 (boolexp -> boolexp OR boolexp .)
  ! reduce/reduce conflict for ^ resolved using rule 32 (boolexp -> boolexp OR boolexp .)
    ;               reduce using rule 32 (boolexp -> boolexp OR boolexp .)
    +               reduce using rule 32 (boolexp -> boolexp OR boolexp .)
    -               reduce using rule 32 (boolexp -> boolexp OR boolexp .)
    *               reduce using rule 32 (boolexp -> boolexp OR boolexp .)
    /               reduce using rule 32 (boolexp -> boolexp OR boolexp .)
    ^               reduce using rule 32 (boolexp -> boolexp OR boolexp .)
    GT              reduce using rule 32 (boolexp -> boolexp OR boolexp .)
    LT              reduce using rule 32 (boolexp -> boolexp OR boolexp .)
    GE              reduce using rule 32 (boolexp -> boolexp OR boolexp .)
    LE              reduce using rule 32 (boolexp -> boolexp OR boolexp .)
    EQ              reduce using rule 32 (boolexp -> boolexp OR boolexp .)
    NE              reduce using rule 32 (boolexp -> boolexp OR boolexp .)
    )               reduce using rule 32 (boolexp -> boolexp OR boolexp .)
    AND             shift and go to state 50
    OR              shift and go to state 51

  ! AND             [ reduce using rule 32 (boolexp -> boolexp OR boolexp .) ]
  ! OR              [ reduce using rule 32 (boolexp -> boolexp OR boolexp .) ]
  ! GT              [ reduce using rule 35 (expression -> boolexp .) ]
  ! LT              [ reduce using rule 35 (expression -> boolexp .) ]
  ! GE              [ reduce using rule 35 (expression -> boolexp .) ]
  ! LE              [ reduce using rule 35 (expression -> boolexp .) ]
  ! EQ              [ reduce using rule 35 (expression -> boolexp .) ]
  ! NE              [ reduce using rule 35 (expression -> boolexp .) ]
  ! +               [ reduce using rule 35 (expression -> boolexp .) ]
  ! -               [ reduce using rule 35 (expression -> boolexp .) ]
  ! *               [ reduce using rule 35 (expression -> boolexp .) ]
  ! /               [ reduce using rule 35 (expression -> boolexp .) ]
  ! ^               [ reduce using rule 35 (expression -> boolexp .) ]


state 73

    (13) statement -> IF ( boolexp ) . { stmts }
    (14) statement -> IF ( boolexp ) . { stmts } ELSE { stmts }
    (17) statement -> IF ( boolexp ) . { stmts } elifstatement ELSE { stmts }

    {               shift and go to state 79


state 74

    (5) statement -> INTDCL NAME = expression ; .

    INTDCL          reduce using rule 5 (statement -> INTDCL NAME = expression ; .)
    FLOATDCL        reduce using rule 5 (statement -> INTDCL NAME = expression ; .)
    BOOLDCL         reduce using rule 5 (statement -> INTDCL NAME = expression ; .)
    WHILE           reduce using rule 5 (statement -> INTDCL NAME = expression ; .)
    FOR             reduce using rule 5 (statement -> INTDCL NAME = expression ; .)
    PRINT           reduce using rule 5 (statement -> INTDCL NAME = expression ; .)
    IF              reduce using rule 5 (statement -> INTDCL NAME = expression ; .)
    NAME            reduce using rule 5 (statement -> INTDCL NAME = expression ; .)
    $end            reduce using rule 5 (statement -> INTDCL NAME = expression ; .)
    }               reduce using rule 5 (statement -> INTDCL NAME = expression ; .)
    BOOLVAL         reduce using rule 5 (statement -> INTDCL NAME = expression ; .)
    (               reduce using rule 5 (statement -> INTDCL NAME = expression ; .)
    INUMBER         reduce using rule 5 (statement -> INTDCL NAME = expression ; .)
    FNUMBER         reduce using rule 5 (statement -> INTDCL NAME = expression ; .)
    )               reduce using rule 5 (statement -> INTDCL NAME = expression ; .)


state 75

    (7) statement -> FLOATDCL NAME = expression ; .

    INTDCL          reduce using rule 7 (statement -> FLOATDCL NAME = expression ; .)
    FLOATDCL        reduce using rule 7 (statement -> FLOATDCL NAME = expression ; .)
    BOOLDCL         reduce using rule 7 (statement -> FLOATDCL NAME = expression ; .)
    WHILE           reduce using rule 7 (statement -> FLOATDCL NAME = expression ; .)
    FOR             reduce using rule 7 (statement -> FLOATDCL NAME = expression ; .)
    PRINT           reduce using rule 7 (statement -> FLOATDCL NAME = expression ; .)
    IF              reduce using rule 7 (statement -> FLOATDCL NAME = expression ; .)
    NAME            reduce using rule 7 (statement -> FLOATDCL NAME = expression ; .)
    $end            reduce using rule 7 (statement -> FLOATDCL NAME = expression ; .)
    }               reduce using rule 7 (statement -> FLOATDCL NAME = expression ; .)
    BOOLVAL         reduce using rule 7 (statement -> FLOATDCL NAME = expression ; .)
    (               reduce using rule 7 (statement -> FLOATDCL NAME = expression ; .)
    INUMBER         reduce using rule 7 (statement -> FLOATDCL NAME = expression ; .)
    FNUMBER         reduce using rule 7 (statement -> FLOATDCL NAME = expression ; .)
    )               reduce using rule 7 (statement -> FLOATDCL NAME = expression ; .)


state 76

    (9) statement -> BOOLDCL NAME = boolexp ; .

    INTDCL          reduce using rule 9 (statement -> BOOLDCL NAME = boolexp ; .)
    FLOATDCL        reduce using rule 9 (statement -> BOOLDCL NAME = boolexp ; .)
    BOOLDCL         reduce using rule 9 (statement -> BOOLDCL NAME = boolexp ; .)
    WHILE           reduce using rule 9 (statement -> BOOLDCL NAME = boolexp ; .)
    FOR             reduce using rule 9 (statement -> BOOLDCL NAME = boolexp ; .)
    PRINT           reduce using rule 9 (statement -> BOOLDCL NAME = boolexp ; .)
    IF              reduce using rule 9 (statement -> BOOLDCL NAME = boolexp ; .)
    NAME            reduce using rule 9 (statement -> BOOLDCL NAME = boolexp ; .)
    $end            reduce using rule 9 (statement -> BOOLDCL NAME = boolexp ; .)
    }               reduce using rule 9 (statement -> BOOLDCL NAME = boolexp ; .)
    BOOLVAL         reduce using rule 9 (statement -> BOOLDCL NAME = boolexp ; .)
    (               reduce using rule 9 (statement -> BOOLDCL NAME = boolexp ; .)
    INUMBER         reduce using rule 9 (statement -> BOOLDCL NAME = boolexp ; .)
    FNUMBER         reduce using rule 9 (statement -> BOOLDCL NAME = boolexp ; .)
    )               reduce using rule 9 (statement -> BOOLDCL NAME = boolexp ; .)


state 77

    (10) statement -> WHILE ( boolexp ) { . stmts }
    (2) stmts -> . statement stmts
    (3) stmts -> . statement
    (4) statement -> . INTDCL NAME ;
    (5) statement -> . INTDCL NAME = expression ;
    (6) statement -> . FLOATDCL NAME ;
    (7) statement -> . FLOATDCL NAME = expression ;
    (8) statement -> . BOOLDCL NAME ;
    (9) statement -> . BOOLDCL NAME = boolexp ;
    (10) statement -> . WHILE ( boolexp ) { stmts }
    (11) statement -> . FOR ( statement boolexp ; statement ) { stmts }
    (12) statement -> . PRINT expression ;
    (13) statement -> . IF ( boolexp ) { stmts }
    (14) statement -> . IF ( boolexp ) { stmts } ELSE { stmts }
    (17) statement -> . IF ( boolexp ) { stmts } elifstatement ELSE { stmts }
    (18) statement -> . NAME = expression ;

    INTDCL          shift and go to state 4
    FLOATDCL        shift and go to state 6
    BOOLDCL         shift and go to state 7
    WHILE           shift and go to state 8
    FOR             shift and go to state 9
    PRINT           shift and go to state 10
    IF              shift and go to state 11
    NAME            shift and go to state 5

    stmts                          shift and go to state 80
    statement                      shift and go to state 3

state 78

    (11) statement -> FOR ( statement boolexp ; . statement ) { stmts }
    (4) statement -> . INTDCL NAME ;
    (5) statement -> . INTDCL NAME = expression ;
    (6) statement -> . FLOATDCL NAME ;
    (7) statement -> . FLOATDCL NAME = expression ;
    (8) statement -> . BOOLDCL NAME ;
    (9) statement -> . BOOLDCL NAME = boolexp ;
    (10) statement -> . WHILE ( boolexp ) { stmts }
    (11) statement -> . FOR ( statement boolexp ; statement ) { stmts }
    (12) statement -> . PRINT expression ;
    (13) statement -> . IF ( boolexp ) { stmts }
    (14) statement -> . IF ( boolexp ) { stmts } ELSE { stmts }
    (17) statement -> . IF ( boolexp ) { stmts } elifstatement ELSE { stmts }
    (18) statement -> . NAME = expression ;

    INTDCL          shift and go to state 4
    FLOATDCL        shift and go to state 6
    BOOLDCL         shift and go to state 7
    WHILE           shift and go to state 8
    FOR             shift and go to state 9
    PRINT           shift and go to state 10
    IF              shift and go to state 11
    NAME            shift and go to state 5

    statement                      shift and go to state 81

state 79

    (13) statement -> IF ( boolexp ) { . stmts }
    (14) statement -> IF ( boolexp ) { . stmts } ELSE { stmts }
    (17) statement -> IF ( boolexp ) { . stmts } elifstatement ELSE { stmts }
    (2) stmts -> . statement stmts
    (3) stmts -> . statement
    (4) statement -> . INTDCL NAME ;
    (5) statement -> . INTDCL NAME = expression ;
    (6) statement -> . FLOATDCL NAME ;
    (7) statement -> . FLOATDCL NAME = expression ;
    (8) statement -> . BOOLDCL NAME ;
    (9) statement -> . BOOLDCL NAME = boolexp ;
    (10) statement -> . WHILE ( boolexp ) { stmts }
    (11) statement -> . FOR ( statement boolexp ; statement ) { stmts }
    (12) statement -> . PRINT expression ;
    (13) statement -> . IF ( boolexp ) { stmts }
    (14) statement -> . IF ( boolexp ) { stmts } ELSE { stmts }
    (17) statement -> . IF ( boolexp ) { stmts } elifstatement ELSE { stmts }
    (18) statement -> . NAME = expression ;

    INTDCL          shift and go to state 4
    FLOATDCL        shift and go to state 6
    BOOLDCL         shift and go to state 7
    WHILE           shift and go to state 8
    FOR             shift and go to state 9
    PRINT           shift and go to state 10
    IF              shift and go to state 11
    NAME            shift and go to state 5

    stmts                          shift and go to state 82
    statement                      shift and go to state 3

state 80

    (10) statement -> WHILE ( boolexp ) { stmts . }

    }               shift and go to state 83


state 81

    (11) statement -> FOR ( statement boolexp ; statement . ) { stmts }

    )               shift and go to state 84


state 82

    (13) statement -> IF ( boolexp ) { stmts . }
    (14) statement -> IF ( boolexp ) { stmts . } ELSE { stmts }
    (17) statement -> IF ( boolexp ) { stmts . } elifstatement ELSE { stmts }

    }               shift and go to state 85


state 83

    (10) statement -> WHILE ( boolexp ) { stmts } .

    INTDCL          reduce using rule 10 (statement -> WHILE ( boolexp ) { stmts } .)
    FLOATDCL        reduce using rule 10 (statement -> WHILE ( boolexp ) { stmts } .)
    BOOLDCL         reduce using rule 10 (statement -> WHILE ( boolexp ) { stmts } .)
    WHILE           reduce using rule 10 (statement -> WHILE ( boolexp ) { stmts } .)
    FOR             reduce using rule 10 (statement -> WHILE ( boolexp ) { stmts } .)
    PRINT           reduce using rule 10 (statement -> WHILE ( boolexp ) { stmts } .)
    IF              reduce using rule 10 (statement -> WHILE ( boolexp ) { stmts } .)
    NAME            reduce using rule 10 (statement -> WHILE ( boolexp ) { stmts } .)
    $end            reduce using rule 10 (statement -> WHILE ( boolexp ) { stmts } .)
    }               reduce using rule 10 (statement -> WHILE ( boolexp ) { stmts } .)
    BOOLVAL         reduce using rule 10 (statement -> WHILE ( boolexp ) { stmts } .)
    (               reduce using rule 10 (statement -> WHILE ( boolexp ) { stmts } .)
    INUMBER         reduce using rule 10 (statement -> WHILE ( boolexp ) { stmts } .)
    FNUMBER         reduce using rule 10 (statement -> WHILE ( boolexp ) { stmts } .)
    )               reduce using rule 10 (statement -> WHILE ( boolexp ) { stmts } .)


state 84

    (11) statement -> FOR ( statement boolexp ; statement ) . { stmts }

    {               shift and go to state 86


state 85

    (13) statement -> IF ( boolexp ) { stmts } .
    (14) statement -> IF ( boolexp ) { stmts } . ELSE { stmts }
    (17) statement -> IF ( boolexp ) { stmts } . elifstatement ELSE { stmts }
    (15) elifstatement -> . ELIF ( boolexp ) { stmts } elifstatement
    (16) elifstatement -> . ELIF ( boolexp ) { stmts }

    INTDCL          reduce using rule 13 (statement -> IF ( boolexp ) { stmts } .)
    FLOATDCL        reduce using rule 13 (statement -> IF ( boolexp ) { stmts } .)
    BOOLDCL         reduce using rule 13 (statement -> IF ( boolexp ) { stmts } .)
    WHILE           reduce using rule 13 (statement -> IF ( boolexp ) { stmts } .)
    FOR             reduce using rule 13 (statement -> IF ( boolexp ) { stmts } .)
    PRINT           reduce using rule 13 (statement -> IF ( boolexp ) { stmts } .)
    IF              reduce using rule 13 (statement -> IF ( boolexp ) { stmts } .)
    NAME            reduce using rule 13 (statement -> IF ( boolexp ) { stmts } .)
    $end            reduce using rule 13 (statement -> IF ( boolexp ) { stmts } .)
    }               reduce using rule 13 (statement -> IF ( boolexp ) { stmts } .)
    BOOLVAL         reduce using rule 13 (statement -> IF ( boolexp ) { stmts } .)
    (               reduce using rule 13 (statement -> IF ( boolexp ) { stmts } .)
    INUMBER         reduce using rule 13 (statement -> IF ( boolexp ) { stmts } .)
    FNUMBER         reduce using rule 13 (statement -> IF ( boolexp ) { stmts } .)
    )               reduce using rule 13 (statement -> IF ( boolexp ) { stmts } .)
    ELSE            shift and go to state 87
    ELIF            shift and go to state 89

    elifstatement                  shift and go to state 88

state 86

    (11) statement -> FOR ( statement boolexp ; statement ) { . stmts }
    (2) stmts -> . statement stmts
    (3) stmts -> . statement
    (4) statement -> . INTDCL NAME ;
    (5) statement -> . INTDCL NAME = expression ;
    (6) statement -> . FLOATDCL NAME ;
    (7) statement -> . FLOATDCL NAME = expression ;
    (8) statement -> . BOOLDCL NAME ;
    (9) statement -> . BOOLDCL NAME = boolexp ;
    (10) statement -> . WHILE ( boolexp ) { stmts }
    (11) statement -> . FOR ( statement boolexp ; statement ) { stmts }
    (12) statement -> . PRINT expression ;
    (13) statement -> . IF ( boolexp ) { stmts }
    (14) statement -> . IF ( boolexp ) { stmts } ELSE { stmts }
    (17) statement -> . IF ( boolexp ) { stmts } elifstatement ELSE { stmts }
    (18) statement -> . NAME = expression ;

    INTDCL          shift and go to state 4
    FLOATDCL        shift and go to state 6
    BOOLDCL         shift and go to state 7
    WHILE           shift and go to state 8
    FOR             shift and go to state 9
    PRINT           shift and go to state 10
    IF              shift and go to state 11
    NAME            shift and go to state 5

    statement                      shift and go to state 3
    stmts                          shift and go to state 90

state 87

    (14) statement -> IF ( boolexp ) { stmts } ELSE . { stmts }

    {               shift and go to state 91


state 88

    (17) statement -> IF ( boolexp ) { stmts } elifstatement . ELSE { stmts }

    ELSE            shift and go to state 92


state 89

    (15) elifstatement -> ELIF . ( boolexp ) { stmts } elifstatement
    (16) elifstatement -> ELIF . ( boolexp ) { stmts }

    (               shift and go to state 93


state 90

    (11) statement -> FOR ( statement boolexp ; statement ) { stmts . }

    }               shift and go to state 94


state 91

    (14) statement -> IF ( boolexp ) { stmts } ELSE { . stmts }
    (2) stmts -> . statement stmts
    (3) stmts -> . statement
    (4) statement -> . INTDCL NAME ;
    (5) statement -> . INTDCL NAME = expression ;
    (6) statement -> . FLOATDCL NAME ;
    (7) statement -> . FLOATDCL NAME = expression ;
    (8) statement -> . BOOLDCL NAME ;
    (9) statement -> . BOOLDCL NAME = boolexp ;
    (10) statement -> . WHILE ( boolexp ) { stmts }
    (11) statement -> . FOR ( statement boolexp ; statement ) { stmts }
    (12) statement -> . PRINT expression ;
    (13) statement -> . IF ( boolexp ) { stmts }
    (14) statement -> . IF ( boolexp ) { stmts } ELSE { stmts }
    (17) statement -> . IF ( boolexp ) { stmts } elifstatement ELSE { stmts }
    (18) statement -> . NAME = expression ;

    INTDCL          shift and go to state 4
    FLOATDCL        shift and go to state 6
    BOOLDCL         shift and go to state 7
    WHILE           shift and go to state 8
    FOR             shift and go to state 9
    PRINT           shift and go to state 10
    IF              shift and go to state 11
    NAME            shift and go to state 5

    stmts                          shift and go to state 95
    statement                      shift and go to state 3

state 92

    (17) statement -> IF ( boolexp ) { stmts } elifstatement ELSE . { stmts }

    {               shift and go to state 96


state 93

    (15) elifstatement -> ELIF ( . boolexp ) { stmts } elifstatement
    (16) elifstatement -> ELIF ( . boolexp ) { stmts }
    (25) boolexp -> . expression GT expression
    (26) boolexp -> . expression LT expression
    (27) boolexp -> . expression GE expression
    (28) boolexp -> . expression LE expression
    (29) boolexp -> . expression EQ expression
    (30) boolexp -> . expression NE expression
    (31) boolexp -> . boolexp AND boolexp
    (32) boolexp -> . boolexp OR boolexp
    (36) boolexp -> . BOOLVAL
    (19) expression -> . ( expression )
    (20) expression -> . expression + expression
    (21) expression -> . expression - expression
    (22) expression -> . expression * expression
    (23) expression -> . expression / expression
    (24) expression -> . expression ^ expression
    (33) expression -> . INUMBER
    (34) expression -> . FNUMBER
    (35) expression -> . boolexp
    (37) expression -> . NAME

    BOOLVAL         shift and go to state 25
    (               shift and go to state 20
    INUMBER         shift and go to state 21
    FNUMBER         shift and go to state 22
    NAME            shift and go to state 24

    boolexp                        shift and go to state 97
    expression                     shift and go to state 35

state 94

    (11) statement -> FOR ( statement boolexp ; statement ) { stmts } .

    INTDCL          reduce using rule 11 (statement -> FOR ( statement boolexp ; statement ) { stmts } .)
    FLOATDCL        reduce using rule 11 (statement -> FOR ( statement boolexp ; statement ) { stmts } .)
    BOOLDCL         reduce using rule 11 (statement -> FOR ( statement boolexp ; statement ) { stmts } .)
    WHILE           reduce using rule 11 (statement -> FOR ( statement boolexp ; statement ) { stmts } .)
    FOR             reduce using rule 11 (statement -> FOR ( statement boolexp ; statement ) { stmts } .)
    PRINT           reduce using rule 11 (statement -> FOR ( statement boolexp ; statement ) { stmts } .)
    IF              reduce using rule 11 (statement -> FOR ( statement boolexp ; statement ) { stmts } .)
    NAME            reduce using rule 11 (statement -> FOR ( statement boolexp ; statement ) { stmts } .)
    $end            reduce using rule 11 (statement -> FOR ( statement boolexp ; statement ) { stmts } .)
    }               reduce using rule 11 (statement -> FOR ( statement boolexp ; statement ) { stmts } .)
    BOOLVAL         reduce using rule 11 (statement -> FOR ( statement boolexp ; statement ) { stmts } .)
    (               reduce using rule 11 (statement -> FOR ( statement boolexp ; statement ) { stmts } .)
    INUMBER         reduce using rule 11 (statement -> FOR ( statement boolexp ; statement ) { stmts } .)
    FNUMBER         reduce using rule 11 (statement -> FOR ( statement boolexp ; statement ) { stmts } .)
    )               reduce using rule 11 (statement -> FOR ( statement boolexp ; statement ) { stmts } .)


state 95

    (14) statement -> IF ( boolexp ) { stmts } ELSE { stmts . }

    }               shift and go to state 98


state 96

    (17) statement -> IF ( boolexp ) { stmts } elifstatement ELSE { . stmts }
    (2) stmts -> . statement stmts
    (3) stmts -> . statement
    (4) statement -> . INTDCL NAME ;
    (5) statement -> . INTDCL NAME = expression ;
    (6) statement -> . FLOATDCL NAME ;
    (7) statement -> . FLOATDCL NAME = expression ;
    (8) statement -> . BOOLDCL NAME ;
    (9) statement -> . BOOLDCL NAME = boolexp ;
    (10) statement -> . WHILE ( boolexp ) { stmts }
    (11) statement -> . FOR ( statement boolexp ; statement ) { stmts }
    (12) statement -> . PRINT expression ;
    (13) statement -> . IF ( boolexp ) { stmts }
    (14) statement -> . IF ( boolexp ) { stmts } ELSE { stmts }
    (17) statement -> . IF ( boolexp ) { stmts } elifstatement ELSE { stmts }
    (18) statement -> . NAME = expression ;

    INTDCL          shift and go to state 4
    FLOATDCL        shift and go to state 6
    BOOLDCL         shift and go to state 7
    WHILE           shift and go to state 8
    FOR             shift and go to state 9
    PRINT           shift and go to state 10
    IF              shift and go to state 11
    NAME            shift and go to state 5

    stmts                          shift and go to state 99
    statement                      shift and go to state 3

state 97

    (15) elifstatement -> ELIF ( boolexp . ) { stmts } elifstatement
    (16) elifstatement -> ELIF ( boolexp . ) { stmts }
    (31) boolexp -> boolexp . AND boolexp
    (32) boolexp -> boolexp . OR boolexp
    (35) expression -> boolexp .

    )               shift and go to state 100
    AND             shift and go to state 50
    OR              shift and go to state 51
    GT              reduce using rule 35 (expression -> boolexp .)
    LT              reduce using rule 35 (expression -> boolexp .)
    GE              reduce using rule 35 (expression -> boolexp .)
    LE              reduce using rule 35 (expression -> boolexp .)
    EQ              reduce using rule 35 (expression -> boolexp .)
    NE              reduce using rule 35 (expression -> boolexp .)
    +               reduce using rule 35 (expression -> boolexp .)
    -               reduce using rule 35 (expression -> boolexp .)
    *               reduce using rule 35 (expression -> boolexp .)
    /               reduce using rule 35 (expression -> boolexp .)
    ^               reduce using rule 35 (expression -> boolexp .)


state 98

    (14) statement -> IF ( boolexp ) { stmts } ELSE { stmts } .

    INTDCL          reduce using rule 14 (statement -> IF ( boolexp ) { stmts } ELSE { stmts } .)
    FLOATDCL        reduce using rule 14 (statement -> IF ( boolexp ) { stmts } ELSE { stmts } .)
    BOOLDCL         reduce using rule 14 (statement -> IF ( boolexp ) { stmts } ELSE { stmts } .)
    WHILE           reduce using rule 14 (statement -> IF ( boolexp ) { stmts } ELSE { stmts } .)
    FOR             reduce using rule 14 (statement -> IF ( boolexp ) { stmts } ELSE { stmts } .)
    PRINT           reduce using rule 14 (statement -> IF ( boolexp ) { stmts } ELSE { stmts } .)
    IF              reduce using rule 14 (statement -> IF ( boolexp ) { stmts } ELSE { stmts } .)
    NAME            reduce using rule 14 (statement -> IF ( boolexp ) { stmts } ELSE { stmts } .)
    $end            reduce using rule 14 (statement -> IF ( boolexp ) { stmts } ELSE { stmts } .)
    }               reduce using rule 14 (statement -> IF ( boolexp ) { stmts } ELSE { stmts } .)
    BOOLVAL         reduce using rule 14 (statement -> IF ( boolexp ) { stmts } ELSE { stmts } .)
    (               reduce using rule 14 (statement -> IF ( boolexp ) { stmts } ELSE { stmts } .)
    INUMBER         reduce using rule 14 (statement -> IF ( boolexp ) { stmts } ELSE { stmts } .)
    FNUMBER         reduce using rule 14 (statement -> IF ( boolexp ) { stmts } ELSE { stmts } .)
    )               reduce using rule 14 (statement -> IF ( boolexp ) { stmts } ELSE { stmts } .)


state 99

    (17) statement -> IF ( boolexp ) { stmts } elifstatement ELSE { stmts . }

    }               shift and go to state 101


state 100

    (15) elifstatement -> ELIF ( boolexp ) . { stmts } elifstatement
    (16) elifstatement -> ELIF ( boolexp ) . { stmts }

    {               shift and go to state 102


state 101

    (17) statement -> IF ( boolexp ) { stmts } elifstatement ELSE { stmts } .

    INTDCL          reduce using rule 17 (statement -> IF ( boolexp ) { stmts } elifstatement ELSE { stmts } .)
    FLOATDCL        reduce using rule 17 (statement -> IF ( boolexp ) { stmts } elifstatement ELSE { stmts } .)
    BOOLDCL         reduce using rule 17 (statement -> IF ( boolexp ) { stmts } elifstatement ELSE { stmts } .)
    WHILE           reduce using rule 17 (statement -> IF ( boolexp ) { stmts } elifstatement ELSE { stmts } .)
    FOR             reduce using rule 17 (statement -> IF ( boolexp ) { stmts } elifstatement ELSE { stmts } .)
    PRINT           reduce using rule 17 (statement -> IF ( boolexp ) { stmts } elifstatement ELSE { stmts } .)
    IF              reduce using rule 17 (statement -> IF ( boolexp ) { stmts } elifstatement ELSE { stmts } .)
    NAME            reduce using rule 17 (statement -> IF ( boolexp ) { stmts } elifstatement ELSE { stmts } .)
    $end            reduce using rule 17 (statement -> IF ( boolexp ) { stmts } elifstatement ELSE { stmts } .)
    }               reduce using rule 17 (statement -> IF ( boolexp ) { stmts } elifstatement ELSE { stmts } .)
    BOOLVAL         reduce using rule 17 (statement -> IF ( boolexp ) { stmts } elifstatement ELSE { stmts } .)
    (               reduce using rule 17 (statement -> IF ( boolexp ) { stmts } elifstatement ELSE { stmts } .)
    INUMBER         reduce using rule 17 (statement -> IF ( boolexp ) { stmts } elifstatement ELSE { stmts } .)
    FNUMBER         reduce using rule 17 (statement -> IF ( boolexp ) { stmts } elifstatement ELSE { stmts } .)
    )               reduce using rule 17 (statement -> IF ( boolexp ) { stmts } elifstatement ELSE { stmts } .)


state 102

    (15) elifstatement -> ELIF ( boolexp ) { . stmts } elifstatement
    (16) elifstatement -> ELIF ( boolexp ) { . stmts }
    (2) stmts -> . statement stmts
    (3) stmts -> . statement
    (4) statement -> . INTDCL NAME ;
    (5) statement -> . INTDCL NAME = expression ;
    (6) statement -> . FLOATDCL NAME ;
    (7) statement -> . FLOATDCL NAME = expression ;
    (8) statement -> . BOOLDCL NAME ;
    (9) statement -> . BOOLDCL NAME = boolexp ;
    (10) statement -> . WHILE ( boolexp ) { stmts }
    (11) statement -> . FOR ( statement boolexp ; statement ) { stmts }
    (12) statement -> . PRINT expression ;
    (13) statement -> . IF ( boolexp ) { stmts }
    (14) statement -> . IF ( boolexp ) { stmts } ELSE { stmts }
    (17) statement -> . IF ( boolexp ) { stmts } elifstatement ELSE { stmts }
    (18) statement -> . NAME = expression ;

    INTDCL          shift and go to state 4
    FLOATDCL        shift and go to state 6
    BOOLDCL         shift and go to state 7
    WHILE           shift and go to state 8
    FOR             shift and go to state 9
    PRINT           shift and go to state 10
    IF              shift and go to state 11
    NAME            shift and go to state 5

    stmts                          shift and go to state 103
    statement                      shift and go to state 3

state 103

    (15) elifstatement -> ELIF ( boolexp ) { stmts . } elifstatement
    (16) elifstatement -> ELIF ( boolexp ) { stmts . }

    }               shift and go to state 104


state 104

    (15) elifstatement -> ELIF ( boolexp ) { stmts } . elifstatement
    (16) elifstatement -> ELIF ( boolexp ) { stmts } .
    (15) elifstatement -> . ELIF ( boolexp ) { stmts } elifstatement
    (16) elifstatement -> . ELIF ( boolexp ) { stmts }

    ELSE            reduce using rule 16 (elifstatement -> ELIF ( boolexp ) { stmts } .)
    ELIF            shift and go to state 89

    elifstatement                  shift and go to state 105

state 105

    (15) elifstatement -> ELIF ( boolexp ) { stmts } elifstatement .

    ELSE            reduce using rule 15 (elifstatement -> ELIF ( boolexp ) { stmts } elifstatement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for AND in state 23 resolved as shift
WARNING: shift/reduce conflict for OR in state 23 resolved as shift
WARNING: shift/reduce conflict for + in state 59 resolved as shift
WARNING: shift/reduce conflict for - in state 59 resolved as shift
WARNING: shift/reduce conflict for * in state 59 resolved as shift
WARNING: shift/reduce conflict for / in state 59 resolved as shift
WARNING: shift/reduce conflict for ^ in state 59 resolved as shift
WARNING: shift/reduce conflict for GT in state 59 resolved as shift
WARNING: shift/reduce conflict for LT in state 59 resolved as shift
WARNING: shift/reduce conflict for GE in state 59 resolved as shift
WARNING: shift/reduce conflict for LE in state 59 resolved as shift
WARNING: shift/reduce conflict for EQ in state 59 resolved as shift
WARNING: shift/reduce conflict for NE in state 59 resolved as shift
WARNING: shift/reduce conflict for + in state 60 resolved as shift
WARNING: shift/reduce conflict for - in state 60 resolved as shift
WARNING: shift/reduce conflict for * in state 60 resolved as shift
WARNING: shift/reduce conflict for / in state 60 resolved as shift
WARNING: shift/reduce conflict for ^ in state 60 resolved as shift
WARNING: shift/reduce conflict for GT in state 60 resolved as shift
WARNING: shift/reduce conflict for LT in state 60 resolved as shift
WARNING: shift/reduce conflict for GE in state 60 resolved as shift
WARNING: shift/reduce conflict for LE in state 60 resolved as shift
WARNING: shift/reduce conflict for EQ in state 60 resolved as shift
WARNING: shift/reduce conflict for NE in state 60 resolved as shift
WARNING: shift/reduce conflict for + in state 61 resolved as shift
WARNING: shift/reduce conflict for - in state 61 resolved as shift
WARNING: shift/reduce conflict for * in state 61 resolved as shift
WARNING: shift/reduce conflict for / in state 61 resolved as shift
WARNING: shift/reduce conflict for ^ in state 61 resolved as shift
WARNING: shift/reduce conflict for GT in state 61 resolved as shift
WARNING: shift/reduce conflict for LT in state 61 resolved as shift
WARNING: shift/reduce conflict for GE in state 61 resolved as shift
WARNING: shift/reduce conflict for LE in state 61 resolved as shift
WARNING: shift/reduce conflict for EQ in state 61 resolved as shift
WARNING: shift/reduce conflict for NE in state 61 resolved as shift
WARNING: shift/reduce conflict for + in state 62 resolved as shift
WARNING: shift/reduce conflict for - in state 62 resolved as shift
WARNING: shift/reduce conflict for * in state 62 resolved as shift
WARNING: shift/reduce conflict for / in state 62 resolved as shift
WARNING: shift/reduce conflict for ^ in state 62 resolved as shift
WARNING: shift/reduce conflict for GT in state 62 resolved as shift
WARNING: shift/reduce conflict for LT in state 62 resolved as shift
WARNING: shift/reduce conflict for GE in state 62 resolved as shift
WARNING: shift/reduce conflict for LE in state 62 resolved as shift
WARNING: shift/reduce conflict for EQ in state 62 resolved as shift
WARNING: shift/reduce conflict for NE in state 62 resolved as shift
WARNING: shift/reduce conflict for + in state 63 resolved as shift
WARNING: shift/reduce conflict for - in state 63 resolved as shift
WARNING: shift/reduce conflict for * in state 63 resolved as shift
WARNING: shift/reduce conflict for / in state 63 resolved as shift
WARNING: shift/reduce conflict for ^ in state 63 resolved as shift
WARNING: shift/reduce conflict for GT in state 63 resolved as shift
WARNING: shift/reduce conflict for LT in state 63 resolved as shift
WARNING: shift/reduce conflict for GE in state 63 resolved as shift
WARNING: shift/reduce conflict for LE in state 63 resolved as shift
WARNING: shift/reduce conflict for EQ in state 63 resolved as shift
WARNING: shift/reduce conflict for NE in state 63 resolved as shift
WARNING: shift/reduce conflict for + in state 64 resolved as shift
WARNING: shift/reduce conflict for - in state 64 resolved as shift
WARNING: shift/reduce conflict for * in state 64 resolved as shift
WARNING: shift/reduce conflict for / in state 64 resolved as shift
WARNING: shift/reduce conflict for ^ in state 64 resolved as shift
WARNING: shift/reduce conflict for GT in state 64 resolved as shift
WARNING: shift/reduce conflict for LT in state 64 resolved as shift
WARNING: shift/reduce conflict for GE in state 64 resolved as shift
WARNING: shift/reduce conflict for LE in state 64 resolved as shift
WARNING: shift/reduce conflict for EQ in state 64 resolved as shift
WARNING: shift/reduce conflict for NE in state 64 resolved as shift
WARNING: shift/reduce conflict for + in state 65 resolved as shift
WARNING: shift/reduce conflict for - in state 65 resolved as shift
WARNING: shift/reduce conflict for * in state 65 resolved as shift
WARNING: shift/reduce conflict for / in state 65 resolved as shift
WARNING: shift/reduce conflict for ^ in state 65 resolved as shift
WARNING: shift/reduce conflict for GT in state 65 resolved as shift
WARNING: shift/reduce conflict for LT in state 65 resolved as shift
WARNING: shift/reduce conflict for GE in state 65 resolved as shift
WARNING: shift/reduce conflict for LE in state 65 resolved as shift
WARNING: shift/reduce conflict for EQ in state 65 resolved as shift
WARNING: shift/reduce conflict for NE in state 65 resolved as shift
WARNING: shift/reduce conflict for + in state 66 resolved as shift
WARNING: shift/reduce conflict for - in state 66 resolved as shift
WARNING: shift/reduce conflict for * in state 66 resolved as shift
WARNING: shift/reduce conflict for / in state 66 resolved as shift
WARNING: shift/reduce conflict for ^ in state 66 resolved as shift
WARNING: shift/reduce conflict for GT in state 66 resolved as shift
WARNING: shift/reduce conflict for LT in state 66 resolved as shift
WARNING: shift/reduce conflict for GE in state 66 resolved as shift
WARNING: shift/reduce conflict for LE in state 66 resolved as shift
WARNING: shift/reduce conflict for EQ in state 66 resolved as shift
WARNING: shift/reduce conflict for NE in state 66 resolved as shift
WARNING: shift/reduce conflict for + in state 67 resolved as shift
WARNING: shift/reduce conflict for - in state 67 resolved as shift
WARNING: shift/reduce conflict for * in state 67 resolved as shift
WARNING: shift/reduce conflict for / in state 67 resolved as shift
WARNING: shift/reduce conflict for ^ in state 67 resolved as shift
WARNING: shift/reduce conflict for GT in state 67 resolved as shift
WARNING: shift/reduce conflict for LT in state 67 resolved as shift
WARNING: shift/reduce conflict for GE in state 67 resolved as shift
WARNING: shift/reduce conflict for LE in state 67 resolved as shift
WARNING: shift/reduce conflict for EQ in state 67 resolved as shift
WARNING: shift/reduce conflict for NE in state 67 resolved as shift
WARNING: shift/reduce conflict for + in state 68 resolved as shift
WARNING: shift/reduce conflict for - in state 68 resolved as shift
WARNING: shift/reduce conflict for * in state 68 resolved as shift
WARNING: shift/reduce conflict for / in state 68 resolved as shift
WARNING: shift/reduce conflict for ^ in state 68 resolved as shift
WARNING: shift/reduce conflict for GT in state 68 resolved as shift
WARNING: shift/reduce conflict for LT in state 68 resolved as shift
WARNING: shift/reduce conflict for GE in state 68 resolved as shift
WARNING: shift/reduce conflict for LE in state 68 resolved as shift
WARNING: shift/reduce conflict for EQ in state 68 resolved as shift
WARNING: shift/reduce conflict for NE in state 68 resolved as shift
WARNING: shift/reduce conflict for + in state 69 resolved as shift
WARNING: shift/reduce conflict for - in state 69 resolved as shift
WARNING: shift/reduce conflict for * in state 69 resolved as shift
WARNING: shift/reduce conflict for / in state 69 resolved as shift
WARNING: shift/reduce conflict for ^ in state 69 resolved as shift
WARNING: shift/reduce conflict for GT in state 69 resolved as shift
WARNING: shift/reduce conflict for LT in state 69 resolved as shift
WARNING: shift/reduce conflict for GE in state 69 resolved as shift
WARNING: shift/reduce conflict for LE in state 69 resolved as shift
WARNING: shift/reduce conflict for EQ in state 69 resolved as shift
WARNING: shift/reduce conflict for NE in state 69 resolved as shift
WARNING: shift/reduce conflict for AND in state 71 resolved as shift
WARNING: shift/reduce conflict for OR in state 71 resolved as shift
WARNING: shift/reduce conflict for AND in state 72 resolved as shift
WARNING: shift/reduce conflict for OR in state 72 resolved as shift
WARNING: reduce/reduce conflict in state 71 resolved using rule (boolexp -> boolexp AND boolexp)
WARNING: rejected rule (expression -> boolexp) in state 71
WARNING: reduce/reduce conflict in state 72 resolved using rule (boolexp -> boolexp OR boolexp)
WARNING: rejected rule (expression -> boolexp) in state 72
