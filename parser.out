Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ELSE

Grammar

Rule 0     S' -> prog
Rule 1     prog -> stmts
Rule 2     stmts -> statement stmts
Rule 3     stmts -> statement
Rule 4     statement -> INTDCL NAME ;
Rule 5     statement -> FLOATDCL NAME ;
Rule 6     statement -> BOOLDCL NAME ;
Rule 7     statement -> PRINT expression ;
Rule 8     statement -> IF ( boolexp ) { stmts }
Rule 9     statement -> NAME = expression ;
Rule 10    expression -> ( expression )
Rule 11    expression -> expression + expression
Rule 12    expression -> expression - expression
Rule 13    expression -> expression * expression
Rule 14    expression -> expression / expression
Rule 15    expression -> expression ^ expression
Rule 16    expression -> INUMBER
Rule 17    expression -> FNUMBER
Rule 18    expression -> boolexp
Rule 19    boolexp -> BOOLVAL
Rule 20    expression -> NAME

Terminals, with rules where they appear

(                    : 8 10
)                    : 8 10
*                    : 13
+                    : 11
-                    : 12
/                    : 14
;                    : 4 5 6 7 9
=                    : 9
BOOLDCL              : 6
BOOLVAL              : 19
ELSE                 : 
FLOATDCL             : 5
FNUMBER              : 17
IF                   : 8
INTDCL               : 4
INUMBER              : 16
NAME                 : 4 5 6 9 20
PRINT                : 7
^                    : 15
error                : 
{                    : 8
}                    : 8

Nonterminals, with rules where they appear

boolexp              : 8 18
expression           : 7 9 10 11 11 12 12 13 13 14 14 15 15
prog                 : 0
statement            : 2 3
stmts                : 1 2 8

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . stmts
    (2) stmts -> . statement stmts
    (3) stmts -> . statement
    (4) statement -> . INTDCL NAME ;
    (5) statement -> . FLOATDCL NAME ;
    (6) statement -> . BOOLDCL NAME ;
    (7) statement -> . PRINT expression ;
    (8) statement -> . IF ( boolexp ) { stmts }
    (9) statement -> . NAME = expression ;

    INTDCL          shift and go to state 4
    FLOATDCL        shift and go to state 6
    BOOLDCL         shift and go to state 7
    PRINT           shift and go to state 8
    IF              shift and go to state 9
    NAME            shift and go to state 5

    prog                           shift and go to state 1
    stmts                          shift and go to state 2
    statement                      shift and go to state 3

state 1

    (0) S' -> prog .



state 2

    (1) prog -> stmts .

    $end            reduce using rule 1 (prog -> stmts .)


state 3

    (2) stmts -> statement . stmts
    (3) stmts -> statement .
    (2) stmts -> . statement stmts
    (3) stmts -> . statement
    (4) statement -> . INTDCL NAME ;
    (5) statement -> . FLOATDCL NAME ;
    (6) statement -> . BOOLDCL NAME ;
    (7) statement -> . PRINT expression ;
    (8) statement -> . IF ( boolexp ) { stmts }
    (9) statement -> . NAME = expression ;

    $end            reduce using rule 3 (stmts -> statement .)
    }               reduce using rule 3 (stmts -> statement .)
    INTDCL          shift and go to state 4
    FLOATDCL        shift and go to state 6
    BOOLDCL         shift and go to state 7
    PRINT           shift and go to state 8
    IF              shift and go to state 9
    NAME            shift and go to state 5

    statement                      shift and go to state 3
    stmts                          shift and go to state 10

state 4

    (4) statement -> INTDCL . NAME ;

    NAME            shift and go to state 11


state 5

    (9) statement -> NAME . = expression ;

    =               shift and go to state 12


state 6

    (5) statement -> FLOATDCL . NAME ;

    NAME            shift and go to state 13


state 7

    (6) statement -> BOOLDCL . NAME ;

    NAME            shift and go to state 14


state 8

    (7) statement -> PRINT . expression ;
    (10) expression -> . ( expression )
    (11) expression -> . expression + expression
    (12) expression -> . expression - expression
    (13) expression -> . expression * expression
    (14) expression -> . expression / expression
    (15) expression -> . expression ^ expression
    (16) expression -> . INUMBER
    (17) expression -> . FNUMBER
    (18) expression -> . boolexp
    (20) expression -> . NAME
    (19) boolexp -> . BOOLVAL

    (               shift and go to state 16
    INUMBER         shift and go to state 17
    FNUMBER         shift and go to state 18
    NAME            shift and go to state 20
    BOOLVAL         shift and go to state 21

    expression                     shift and go to state 15
    boolexp                        shift and go to state 19

state 9

    (8) statement -> IF . ( boolexp ) { stmts }

    (               shift and go to state 22


state 10

    (2) stmts -> statement stmts .

    $end            reduce using rule 2 (stmts -> statement stmts .)
    }               reduce using rule 2 (stmts -> statement stmts .)


state 11

    (4) statement -> INTDCL NAME . ;

    ;               shift and go to state 23


state 12

    (9) statement -> NAME = . expression ;
    (10) expression -> . ( expression )
    (11) expression -> . expression + expression
    (12) expression -> . expression - expression
    (13) expression -> . expression * expression
    (14) expression -> . expression / expression
    (15) expression -> . expression ^ expression
    (16) expression -> . INUMBER
    (17) expression -> . FNUMBER
    (18) expression -> . boolexp
    (20) expression -> . NAME
    (19) boolexp -> . BOOLVAL

    (               shift and go to state 16
    INUMBER         shift and go to state 17
    FNUMBER         shift and go to state 18
    NAME            shift and go to state 20
    BOOLVAL         shift and go to state 21

    expression                     shift and go to state 24
    boolexp                        shift and go to state 19

state 13

    (5) statement -> FLOATDCL NAME . ;

    ;               shift and go to state 25


state 14

    (6) statement -> BOOLDCL NAME . ;

    ;               shift and go to state 26


state 15

    (7) statement -> PRINT expression . ;
    (11) expression -> expression . + expression
    (12) expression -> expression . - expression
    (13) expression -> expression . * expression
    (14) expression -> expression . / expression
    (15) expression -> expression . ^ expression

    ;               shift and go to state 27
    +               shift and go to state 28
    -               shift and go to state 29
    *               shift and go to state 30
    /               shift and go to state 31
    ^               shift and go to state 32


state 16

    (10) expression -> ( . expression )
    (10) expression -> . ( expression )
    (11) expression -> . expression + expression
    (12) expression -> . expression - expression
    (13) expression -> . expression * expression
    (14) expression -> . expression / expression
    (15) expression -> . expression ^ expression
    (16) expression -> . INUMBER
    (17) expression -> . FNUMBER
    (18) expression -> . boolexp
    (20) expression -> . NAME
    (19) boolexp -> . BOOLVAL

    (               shift and go to state 16
    INUMBER         shift and go to state 17
    FNUMBER         shift and go to state 18
    NAME            shift and go to state 20
    BOOLVAL         shift and go to state 21

    expression                     shift and go to state 33
    boolexp                        shift and go to state 19

state 17

    (16) expression -> INUMBER .

    ;               reduce using rule 16 (expression -> INUMBER .)
    +               reduce using rule 16 (expression -> INUMBER .)
    -               reduce using rule 16 (expression -> INUMBER .)
    *               reduce using rule 16 (expression -> INUMBER .)
    /               reduce using rule 16 (expression -> INUMBER .)
    ^               reduce using rule 16 (expression -> INUMBER .)
    )               reduce using rule 16 (expression -> INUMBER .)


state 18

    (17) expression -> FNUMBER .

    ;               reduce using rule 17 (expression -> FNUMBER .)
    +               reduce using rule 17 (expression -> FNUMBER .)
    -               reduce using rule 17 (expression -> FNUMBER .)
    *               reduce using rule 17 (expression -> FNUMBER .)
    /               reduce using rule 17 (expression -> FNUMBER .)
    ^               reduce using rule 17 (expression -> FNUMBER .)
    )               reduce using rule 17 (expression -> FNUMBER .)


state 19

    (18) expression -> boolexp .

    ;               reduce using rule 18 (expression -> boolexp .)
    +               reduce using rule 18 (expression -> boolexp .)
    -               reduce using rule 18 (expression -> boolexp .)
    *               reduce using rule 18 (expression -> boolexp .)
    /               reduce using rule 18 (expression -> boolexp .)
    ^               reduce using rule 18 (expression -> boolexp .)
    )               reduce using rule 18 (expression -> boolexp .)


state 20

    (20) expression -> NAME .

    ;               reduce using rule 20 (expression -> NAME .)
    +               reduce using rule 20 (expression -> NAME .)
    -               reduce using rule 20 (expression -> NAME .)
    *               reduce using rule 20 (expression -> NAME .)
    /               reduce using rule 20 (expression -> NAME .)
    ^               reduce using rule 20 (expression -> NAME .)
    )               reduce using rule 20 (expression -> NAME .)


state 21

    (19) boolexp -> BOOLVAL .

    ;               reduce using rule 19 (boolexp -> BOOLVAL .)
    +               reduce using rule 19 (boolexp -> BOOLVAL .)
    -               reduce using rule 19 (boolexp -> BOOLVAL .)
    *               reduce using rule 19 (boolexp -> BOOLVAL .)
    /               reduce using rule 19 (boolexp -> BOOLVAL .)
    ^               reduce using rule 19 (boolexp -> BOOLVAL .)
    )               reduce using rule 19 (boolexp -> BOOLVAL .)


state 22

    (8) statement -> IF ( . boolexp ) { stmts }
    (19) boolexp -> . BOOLVAL

    BOOLVAL         shift and go to state 21

    boolexp                        shift and go to state 34

state 23

    (4) statement -> INTDCL NAME ; .

    INTDCL          reduce using rule 4 (statement -> INTDCL NAME ; .)
    FLOATDCL        reduce using rule 4 (statement -> INTDCL NAME ; .)
    BOOLDCL         reduce using rule 4 (statement -> INTDCL NAME ; .)
    PRINT           reduce using rule 4 (statement -> INTDCL NAME ; .)
    IF              reduce using rule 4 (statement -> INTDCL NAME ; .)
    NAME            reduce using rule 4 (statement -> INTDCL NAME ; .)
    $end            reduce using rule 4 (statement -> INTDCL NAME ; .)
    }               reduce using rule 4 (statement -> INTDCL NAME ; .)


state 24

    (9) statement -> NAME = expression . ;
    (11) expression -> expression . + expression
    (12) expression -> expression . - expression
    (13) expression -> expression . * expression
    (14) expression -> expression . / expression
    (15) expression -> expression . ^ expression

    ;               shift and go to state 35
    +               shift and go to state 28
    -               shift and go to state 29
    *               shift and go to state 30
    /               shift and go to state 31
    ^               shift and go to state 32


state 25

    (5) statement -> FLOATDCL NAME ; .

    INTDCL          reduce using rule 5 (statement -> FLOATDCL NAME ; .)
    FLOATDCL        reduce using rule 5 (statement -> FLOATDCL NAME ; .)
    BOOLDCL         reduce using rule 5 (statement -> FLOATDCL NAME ; .)
    PRINT           reduce using rule 5 (statement -> FLOATDCL NAME ; .)
    IF              reduce using rule 5 (statement -> FLOATDCL NAME ; .)
    NAME            reduce using rule 5 (statement -> FLOATDCL NAME ; .)
    $end            reduce using rule 5 (statement -> FLOATDCL NAME ; .)
    }               reduce using rule 5 (statement -> FLOATDCL NAME ; .)


state 26

    (6) statement -> BOOLDCL NAME ; .

    INTDCL          reduce using rule 6 (statement -> BOOLDCL NAME ; .)
    FLOATDCL        reduce using rule 6 (statement -> BOOLDCL NAME ; .)
    BOOLDCL         reduce using rule 6 (statement -> BOOLDCL NAME ; .)
    PRINT           reduce using rule 6 (statement -> BOOLDCL NAME ; .)
    IF              reduce using rule 6 (statement -> BOOLDCL NAME ; .)
    NAME            reduce using rule 6 (statement -> BOOLDCL NAME ; .)
    $end            reduce using rule 6 (statement -> BOOLDCL NAME ; .)
    }               reduce using rule 6 (statement -> BOOLDCL NAME ; .)


state 27

    (7) statement -> PRINT expression ; .

    INTDCL          reduce using rule 7 (statement -> PRINT expression ; .)
    FLOATDCL        reduce using rule 7 (statement -> PRINT expression ; .)
    BOOLDCL         reduce using rule 7 (statement -> PRINT expression ; .)
    PRINT           reduce using rule 7 (statement -> PRINT expression ; .)
    IF              reduce using rule 7 (statement -> PRINT expression ; .)
    NAME            reduce using rule 7 (statement -> PRINT expression ; .)
    $end            reduce using rule 7 (statement -> PRINT expression ; .)
    }               reduce using rule 7 (statement -> PRINT expression ; .)


state 28

    (11) expression -> expression + . expression
    (10) expression -> . ( expression )
    (11) expression -> . expression + expression
    (12) expression -> . expression - expression
    (13) expression -> . expression * expression
    (14) expression -> . expression / expression
    (15) expression -> . expression ^ expression
    (16) expression -> . INUMBER
    (17) expression -> . FNUMBER
    (18) expression -> . boolexp
    (20) expression -> . NAME
    (19) boolexp -> . BOOLVAL

    (               shift and go to state 16
    INUMBER         shift and go to state 17
    FNUMBER         shift and go to state 18
    NAME            shift and go to state 20
    BOOLVAL         shift and go to state 21

    expression                     shift and go to state 36
    boolexp                        shift and go to state 19

state 29

    (12) expression -> expression - . expression
    (10) expression -> . ( expression )
    (11) expression -> . expression + expression
    (12) expression -> . expression - expression
    (13) expression -> . expression * expression
    (14) expression -> . expression / expression
    (15) expression -> . expression ^ expression
    (16) expression -> . INUMBER
    (17) expression -> . FNUMBER
    (18) expression -> . boolexp
    (20) expression -> . NAME
    (19) boolexp -> . BOOLVAL

    (               shift and go to state 16
    INUMBER         shift and go to state 17
    FNUMBER         shift and go to state 18
    NAME            shift and go to state 20
    BOOLVAL         shift and go to state 21

    expression                     shift and go to state 37
    boolexp                        shift and go to state 19

state 30

    (13) expression -> expression * . expression
    (10) expression -> . ( expression )
    (11) expression -> . expression + expression
    (12) expression -> . expression - expression
    (13) expression -> . expression * expression
    (14) expression -> . expression / expression
    (15) expression -> . expression ^ expression
    (16) expression -> . INUMBER
    (17) expression -> . FNUMBER
    (18) expression -> . boolexp
    (20) expression -> . NAME
    (19) boolexp -> . BOOLVAL

    (               shift and go to state 16
    INUMBER         shift and go to state 17
    FNUMBER         shift and go to state 18
    NAME            shift and go to state 20
    BOOLVAL         shift and go to state 21

    expression                     shift and go to state 38
    boolexp                        shift and go to state 19

state 31

    (14) expression -> expression / . expression
    (10) expression -> . ( expression )
    (11) expression -> . expression + expression
    (12) expression -> . expression - expression
    (13) expression -> . expression * expression
    (14) expression -> . expression / expression
    (15) expression -> . expression ^ expression
    (16) expression -> . INUMBER
    (17) expression -> . FNUMBER
    (18) expression -> . boolexp
    (20) expression -> . NAME
    (19) boolexp -> . BOOLVAL

    (               shift and go to state 16
    INUMBER         shift and go to state 17
    FNUMBER         shift and go to state 18
    NAME            shift and go to state 20
    BOOLVAL         shift and go to state 21

    expression                     shift and go to state 39
    boolexp                        shift and go to state 19

state 32

    (15) expression -> expression ^ . expression
    (10) expression -> . ( expression )
    (11) expression -> . expression + expression
    (12) expression -> . expression - expression
    (13) expression -> . expression * expression
    (14) expression -> . expression / expression
    (15) expression -> . expression ^ expression
    (16) expression -> . INUMBER
    (17) expression -> . FNUMBER
    (18) expression -> . boolexp
    (20) expression -> . NAME
    (19) boolexp -> . BOOLVAL

    (               shift and go to state 16
    INUMBER         shift and go to state 17
    FNUMBER         shift and go to state 18
    NAME            shift and go to state 20
    BOOLVAL         shift and go to state 21

    expression                     shift and go to state 40
    boolexp                        shift and go to state 19

state 33

    (10) expression -> ( expression . )
    (11) expression -> expression . + expression
    (12) expression -> expression . - expression
    (13) expression -> expression . * expression
    (14) expression -> expression . / expression
    (15) expression -> expression . ^ expression

    )               shift and go to state 41
    +               shift and go to state 28
    -               shift and go to state 29
    *               shift and go to state 30
    /               shift and go to state 31
    ^               shift and go to state 32


state 34

    (8) statement -> IF ( boolexp . ) { stmts }

    )               shift and go to state 42


state 35

    (9) statement -> NAME = expression ; .

    INTDCL          reduce using rule 9 (statement -> NAME = expression ; .)
    FLOATDCL        reduce using rule 9 (statement -> NAME = expression ; .)
    BOOLDCL         reduce using rule 9 (statement -> NAME = expression ; .)
    PRINT           reduce using rule 9 (statement -> NAME = expression ; .)
    IF              reduce using rule 9 (statement -> NAME = expression ; .)
    NAME            reduce using rule 9 (statement -> NAME = expression ; .)
    $end            reduce using rule 9 (statement -> NAME = expression ; .)
    }               reduce using rule 9 (statement -> NAME = expression ; .)


state 36

    (11) expression -> expression + expression .
    (11) expression -> expression . + expression
    (12) expression -> expression . - expression
    (13) expression -> expression . * expression
    (14) expression -> expression . / expression
    (15) expression -> expression . ^ expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
    ;               reduce using rule 11 (expression -> expression + expression .)
    )               reduce using rule 11 (expression -> expression + expression .)
    +               shift and go to state 28
    -               shift and go to state 29
    *               shift and go to state 30
    /               shift and go to state 31
    ^               shift and go to state 32

  ! +               [ reduce using rule 11 (expression -> expression + expression .) ]
  ! -               [ reduce using rule 11 (expression -> expression + expression .) ]
  ! *               [ reduce using rule 11 (expression -> expression + expression .) ]
  ! /               [ reduce using rule 11 (expression -> expression + expression .) ]
  ! ^               [ reduce using rule 11 (expression -> expression + expression .) ]


state 37

    (12) expression -> expression - expression .
    (11) expression -> expression . + expression
    (12) expression -> expression . - expression
    (13) expression -> expression . * expression
    (14) expression -> expression . / expression
    (15) expression -> expression . ^ expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
    ;               reduce using rule 12 (expression -> expression - expression .)
    )               reduce using rule 12 (expression -> expression - expression .)
    +               shift and go to state 28
    -               shift and go to state 29
    *               shift and go to state 30
    /               shift and go to state 31
    ^               shift and go to state 32

  ! +               [ reduce using rule 12 (expression -> expression - expression .) ]
  ! -               [ reduce using rule 12 (expression -> expression - expression .) ]
  ! *               [ reduce using rule 12 (expression -> expression - expression .) ]
  ! /               [ reduce using rule 12 (expression -> expression - expression .) ]
  ! ^               [ reduce using rule 12 (expression -> expression - expression .) ]


state 38

    (13) expression -> expression * expression .
    (11) expression -> expression . + expression
    (12) expression -> expression . - expression
    (13) expression -> expression . * expression
    (14) expression -> expression . / expression
    (15) expression -> expression . ^ expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
    ;               reduce using rule 13 (expression -> expression * expression .)
    )               reduce using rule 13 (expression -> expression * expression .)
    +               shift and go to state 28
    -               shift and go to state 29
    *               shift and go to state 30
    /               shift and go to state 31
    ^               shift and go to state 32

  ! +               [ reduce using rule 13 (expression -> expression * expression .) ]
  ! -               [ reduce using rule 13 (expression -> expression * expression .) ]
  ! *               [ reduce using rule 13 (expression -> expression * expression .) ]
  ! /               [ reduce using rule 13 (expression -> expression * expression .) ]
  ! ^               [ reduce using rule 13 (expression -> expression * expression .) ]


state 39

    (14) expression -> expression / expression .
    (11) expression -> expression . + expression
    (12) expression -> expression . - expression
    (13) expression -> expression . * expression
    (14) expression -> expression . / expression
    (15) expression -> expression . ^ expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
    ;               reduce using rule 14 (expression -> expression / expression .)
    )               reduce using rule 14 (expression -> expression / expression .)
    +               shift and go to state 28
    -               shift and go to state 29
    *               shift and go to state 30
    /               shift and go to state 31
    ^               shift and go to state 32

  ! +               [ reduce using rule 14 (expression -> expression / expression .) ]
  ! -               [ reduce using rule 14 (expression -> expression / expression .) ]
  ! *               [ reduce using rule 14 (expression -> expression / expression .) ]
  ! /               [ reduce using rule 14 (expression -> expression / expression .) ]
  ! ^               [ reduce using rule 14 (expression -> expression / expression .) ]


state 40

    (15) expression -> expression ^ expression .
    (11) expression -> expression . + expression
    (12) expression -> expression . - expression
    (13) expression -> expression . * expression
    (14) expression -> expression . / expression
    (15) expression -> expression . ^ expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
    ;               reduce using rule 15 (expression -> expression ^ expression .)
    )               reduce using rule 15 (expression -> expression ^ expression .)
    +               shift and go to state 28
    -               shift and go to state 29
    *               shift and go to state 30
    /               shift and go to state 31
    ^               shift and go to state 32

  ! +               [ reduce using rule 15 (expression -> expression ^ expression .) ]
  ! -               [ reduce using rule 15 (expression -> expression ^ expression .) ]
  ! *               [ reduce using rule 15 (expression -> expression ^ expression .) ]
  ! /               [ reduce using rule 15 (expression -> expression ^ expression .) ]
  ! ^               [ reduce using rule 15 (expression -> expression ^ expression .) ]


state 41

    (10) expression -> ( expression ) .

    ;               reduce using rule 10 (expression -> ( expression ) .)
    +               reduce using rule 10 (expression -> ( expression ) .)
    -               reduce using rule 10 (expression -> ( expression ) .)
    *               reduce using rule 10 (expression -> ( expression ) .)
    /               reduce using rule 10 (expression -> ( expression ) .)
    ^               reduce using rule 10 (expression -> ( expression ) .)
    )               reduce using rule 10 (expression -> ( expression ) .)


state 42

    (8) statement -> IF ( boolexp ) . { stmts }

    {               shift and go to state 43


state 43

    (8) statement -> IF ( boolexp ) { . stmts }
    (2) stmts -> . statement stmts
    (3) stmts -> . statement
    (4) statement -> . INTDCL NAME ;
    (5) statement -> . FLOATDCL NAME ;
    (6) statement -> . BOOLDCL NAME ;
    (7) statement -> . PRINT expression ;
    (8) statement -> . IF ( boolexp ) { stmts }
    (9) statement -> . NAME = expression ;

    INTDCL          shift and go to state 4
    FLOATDCL        shift and go to state 6
    BOOLDCL         shift and go to state 7
    PRINT           shift and go to state 8
    IF              shift and go to state 9
    NAME            shift and go to state 5

    stmts                          shift and go to state 44
    statement                      shift and go to state 3

state 44

    (8) statement -> IF ( boolexp ) { stmts . }

    }               shift and go to state 45


state 45

    (8) statement -> IF ( boolexp ) { stmts } .

    INTDCL          reduce using rule 8 (statement -> IF ( boolexp ) { stmts } .)
    FLOATDCL        reduce using rule 8 (statement -> IF ( boolexp ) { stmts } .)
    BOOLDCL         reduce using rule 8 (statement -> IF ( boolexp ) { stmts } .)
    PRINT           reduce using rule 8 (statement -> IF ( boolexp ) { stmts } .)
    IF              reduce using rule 8 (statement -> IF ( boolexp ) { stmts } .)
    NAME            reduce using rule 8 (statement -> IF ( boolexp ) { stmts } .)
    $end            reduce using rule 8 (statement -> IF ( boolexp ) { stmts } .)
    }               reduce using rule 8 (statement -> IF ( boolexp ) { stmts } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for + in state 36 resolved as shift
WARNING: shift/reduce conflict for - in state 36 resolved as shift
WARNING: shift/reduce conflict for * in state 36 resolved as shift
WARNING: shift/reduce conflict for / in state 36 resolved as shift
WARNING: shift/reduce conflict for ^ in state 36 resolved as shift
WARNING: shift/reduce conflict for + in state 37 resolved as shift
WARNING: shift/reduce conflict for - in state 37 resolved as shift
WARNING: shift/reduce conflict for * in state 37 resolved as shift
WARNING: shift/reduce conflict for / in state 37 resolved as shift
WARNING: shift/reduce conflict for ^ in state 37 resolved as shift
WARNING: shift/reduce conflict for + in state 38 resolved as shift
WARNING: shift/reduce conflict for - in state 38 resolved as shift
WARNING: shift/reduce conflict for * in state 38 resolved as shift
WARNING: shift/reduce conflict for / in state 38 resolved as shift
WARNING: shift/reduce conflict for ^ in state 38 resolved as shift
WARNING: shift/reduce conflict for + in state 39 resolved as shift
WARNING: shift/reduce conflict for - in state 39 resolved as shift
WARNING: shift/reduce conflict for * in state 39 resolved as shift
WARNING: shift/reduce conflict for / in state 39 resolved as shift
WARNING: shift/reduce conflict for ^ in state 39 resolved as shift
WARNING: shift/reduce conflict for + in state 40 resolved as shift
WARNING: shift/reduce conflict for - in state 40 resolved as shift
WARNING: shift/reduce conflict for * in state 40 resolved as shift
WARNING: shift/reduce conflict for / in state 40 resolved as shift
WARNING: shift/reduce conflict for ^ in state 40 resolved as shift
