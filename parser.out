Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ELSE

Grammar

Rule 0     S' -> prog
Rule 1     prog -> stmts
Rule 2     stmts -> statement stmts
Rule 3     stmts -> statement
Rule 4     statement -> INTDCL NAME ;
Rule 5     statement -> INTDCL NAME = expression ;
Rule 6     statement -> FLOATDCL NAME ;
Rule 7     statement -> BOOLDCL NAME ;
Rule 8     statement -> PRINT expression ;
Rule 9     statement -> IF ( boolexp ) { stmts }
Rule 10    statement -> NAME = expression ;
Rule 11    expression -> ( expression )
Rule 12    expression -> expression + expression
Rule 13    expression -> expression - expression
Rule 14    expression -> expression * expression
Rule 15    expression -> expression / expression
Rule 16    expression -> expression ^ expression
Rule 17    expression -> INUMBER
Rule 18    expression -> FNUMBER
Rule 19    expression -> boolexp
Rule 20    boolexp -> BOOLVAL
Rule 21    expression -> NAME

Terminals, with rules where they appear

(                    : 9 11
)                    : 9 11
*                    : 14
+                    : 12
-                    : 13
/                    : 15
;                    : 4 5 6 7 8 10
=                    : 5 10
BOOLDCL              : 7
BOOLVAL              : 20
ELSE                 : 
FLOATDCL             : 6
FNUMBER              : 18
IF                   : 9
INTDCL               : 4 5
INUMBER              : 17
NAME                 : 4 5 6 7 10 21
PRINT                : 8
^                    : 16
error                : 
{                    : 9
}                    : 9

Nonterminals, with rules where they appear

boolexp              : 9 19
expression           : 5 8 10 11 12 12 13 13 14 14 15 15 16 16
prog                 : 0
statement            : 2 3
stmts                : 1 2 9

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . stmts
    (2) stmts -> . statement stmts
    (3) stmts -> . statement
    (4) statement -> . INTDCL NAME ;
    (5) statement -> . INTDCL NAME = expression ;
    (6) statement -> . FLOATDCL NAME ;
    (7) statement -> . BOOLDCL NAME ;
    (8) statement -> . PRINT expression ;
    (9) statement -> . IF ( boolexp ) { stmts }
    (10) statement -> . NAME = expression ;

    INTDCL          shift and go to state 4
    FLOATDCL        shift and go to state 6
    BOOLDCL         shift and go to state 7
    PRINT           shift and go to state 8
    IF              shift and go to state 9
    NAME            shift and go to state 5

    prog                           shift and go to state 1
    stmts                          shift and go to state 2
    statement                      shift and go to state 3

state 1

    (0) S' -> prog .



state 2

    (1) prog -> stmts .

    $end            reduce using rule 1 (prog -> stmts .)


state 3

    (2) stmts -> statement . stmts
    (3) stmts -> statement .
    (2) stmts -> . statement stmts
    (3) stmts -> . statement
    (4) statement -> . INTDCL NAME ;
    (5) statement -> . INTDCL NAME = expression ;
    (6) statement -> . FLOATDCL NAME ;
    (7) statement -> . BOOLDCL NAME ;
    (8) statement -> . PRINT expression ;
    (9) statement -> . IF ( boolexp ) { stmts }
    (10) statement -> . NAME = expression ;

    $end            reduce using rule 3 (stmts -> statement .)
    }               reduce using rule 3 (stmts -> statement .)
    INTDCL          shift and go to state 4
    FLOATDCL        shift and go to state 6
    BOOLDCL         shift and go to state 7
    PRINT           shift and go to state 8
    IF              shift and go to state 9
    NAME            shift and go to state 5

    statement                      shift and go to state 3
    stmts                          shift and go to state 10

state 4

    (4) statement -> INTDCL . NAME ;
    (5) statement -> INTDCL . NAME = expression ;

    NAME            shift and go to state 11


state 5

    (10) statement -> NAME . = expression ;

    =               shift and go to state 12


state 6

    (6) statement -> FLOATDCL . NAME ;

    NAME            shift and go to state 13


state 7

    (7) statement -> BOOLDCL . NAME ;

    NAME            shift and go to state 14


state 8

    (8) statement -> PRINT . expression ;
    (11) expression -> . ( expression )
    (12) expression -> . expression + expression
    (13) expression -> . expression - expression
    (14) expression -> . expression * expression
    (15) expression -> . expression / expression
    (16) expression -> . expression ^ expression
    (17) expression -> . INUMBER
    (18) expression -> . FNUMBER
    (19) expression -> . boolexp
    (21) expression -> . NAME
    (20) boolexp -> . BOOLVAL

    (               shift and go to state 16
    INUMBER         shift and go to state 17
    FNUMBER         shift and go to state 18
    NAME            shift and go to state 20
    BOOLVAL         shift and go to state 21

    expression                     shift and go to state 15
    boolexp                        shift and go to state 19

state 9

    (9) statement -> IF . ( boolexp ) { stmts }

    (               shift and go to state 22


state 10

    (2) stmts -> statement stmts .

    $end            reduce using rule 2 (stmts -> statement stmts .)
    }               reduce using rule 2 (stmts -> statement stmts .)


state 11

    (4) statement -> INTDCL NAME . ;
    (5) statement -> INTDCL NAME . = expression ;

    ;               shift and go to state 23
    =               shift and go to state 24


state 12

    (10) statement -> NAME = . expression ;
    (11) expression -> . ( expression )
    (12) expression -> . expression + expression
    (13) expression -> . expression - expression
    (14) expression -> . expression * expression
    (15) expression -> . expression / expression
    (16) expression -> . expression ^ expression
    (17) expression -> . INUMBER
    (18) expression -> . FNUMBER
    (19) expression -> . boolexp
    (21) expression -> . NAME
    (20) boolexp -> . BOOLVAL

    (               shift and go to state 16
    INUMBER         shift and go to state 17
    FNUMBER         shift and go to state 18
    NAME            shift and go to state 20
    BOOLVAL         shift and go to state 21

    expression                     shift and go to state 25
    boolexp                        shift and go to state 19

state 13

    (6) statement -> FLOATDCL NAME . ;

    ;               shift and go to state 26


state 14

    (7) statement -> BOOLDCL NAME . ;

    ;               shift and go to state 27


state 15

    (8) statement -> PRINT expression . ;
    (12) expression -> expression . + expression
    (13) expression -> expression . - expression
    (14) expression -> expression . * expression
    (15) expression -> expression . / expression
    (16) expression -> expression . ^ expression

    ;               shift and go to state 28
    +               shift and go to state 29
    -               shift and go to state 30
    *               shift and go to state 31
    /               shift and go to state 32
    ^               shift and go to state 33


state 16

    (11) expression -> ( . expression )
    (11) expression -> . ( expression )
    (12) expression -> . expression + expression
    (13) expression -> . expression - expression
    (14) expression -> . expression * expression
    (15) expression -> . expression / expression
    (16) expression -> . expression ^ expression
    (17) expression -> . INUMBER
    (18) expression -> . FNUMBER
    (19) expression -> . boolexp
    (21) expression -> . NAME
    (20) boolexp -> . BOOLVAL

    (               shift and go to state 16
    INUMBER         shift and go to state 17
    FNUMBER         shift and go to state 18
    NAME            shift and go to state 20
    BOOLVAL         shift and go to state 21

    expression                     shift and go to state 34
    boolexp                        shift and go to state 19

state 17

    (17) expression -> INUMBER .

    ;               reduce using rule 17 (expression -> INUMBER .)
    +               reduce using rule 17 (expression -> INUMBER .)
    -               reduce using rule 17 (expression -> INUMBER .)
    *               reduce using rule 17 (expression -> INUMBER .)
    /               reduce using rule 17 (expression -> INUMBER .)
    ^               reduce using rule 17 (expression -> INUMBER .)
    )               reduce using rule 17 (expression -> INUMBER .)


state 18

    (18) expression -> FNUMBER .

    ;               reduce using rule 18 (expression -> FNUMBER .)
    +               reduce using rule 18 (expression -> FNUMBER .)
    -               reduce using rule 18 (expression -> FNUMBER .)
    *               reduce using rule 18 (expression -> FNUMBER .)
    /               reduce using rule 18 (expression -> FNUMBER .)
    ^               reduce using rule 18 (expression -> FNUMBER .)
    )               reduce using rule 18 (expression -> FNUMBER .)


state 19

    (19) expression -> boolexp .

    ;               reduce using rule 19 (expression -> boolexp .)
    +               reduce using rule 19 (expression -> boolexp .)
    -               reduce using rule 19 (expression -> boolexp .)
    *               reduce using rule 19 (expression -> boolexp .)
    /               reduce using rule 19 (expression -> boolexp .)
    ^               reduce using rule 19 (expression -> boolexp .)
    )               reduce using rule 19 (expression -> boolexp .)


state 20

    (21) expression -> NAME .

    ;               reduce using rule 21 (expression -> NAME .)
    +               reduce using rule 21 (expression -> NAME .)
    -               reduce using rule 21 (expression -> NAME .)
    *               reduce using rule 21 (expression -> NAME .)
    /               reduce using rule 21 (expression -> NAME .)
    ^               reduce using rule 21 (expression -> NAME .)
    )               reduce using rule 21 (expression -> NAME .)


state 21

    (20) boolexp -> BOOLVAL .

    ;               reduce using rule 20 (boolexp -> BOOLVAL .)
    +               reduce using rule 20 (boolexp -> BOOLVAL .)
    -               reduce using rule 20 (boolexp -> BOOLVAL .)
    *               reduce using rule 20 (boolexp -> BOOLVAL .)
    /               reduce using rule 20 (boolexp -> BOOLVAL .)
    ^               reduce using rule 20 (boolexp -> BOOLVAL .)
    )               reduce using rule 20 (boolexp -> BOOLVAL .)


state 22

    (9) statement -> IF ( . boolexp ) { stmts }
    (20) boolexp -> . BOOLVAL

    BOOLVAL         shift and go to state 21

    boolexp                        shift and go to state 35

state 23

    (4) statement -> INTDCL NAME ; .

    INTDCL          reduce using rule 4 (statement -> INTDCL NAME ; .)
    FLOATDCL        reduce using rule 4 (statement -> INTDCL NAME ; .)
    BOOLDCL         reduce using rule 4 (statement -> INTDCL NAME ; .)
    PRINT           reduce using rule 4 (statement -> INTDCL NAME ; .)
    IF              reduce using rule 4 (statement -> INTDCL NAME ; .)
    NAME            reduce using rule 4 (statement -> INTDCL NAME ; .)
    $end            reduce using rule 4 (statement -> INTDCL NAME ; .)
    }               reduce using rule 4 (statement -> INTDCL NAME ; .)


state 24

    (5) statement -> INTDCL NAME = . expression ;
    (11) expression -> . ( expression )
    (12) expression -> . expression + expression
    (13) expression -> . expression - expression
    (14) expression -> . expression * expression
    (15) expression -> . expression / expression
    (16) expression -> . expression ^ expression
    (17) expression -> . INUMBER
    (18) expression -> . FNUMBER
    (19) expression -> . boolexp
    (21) expression -> . NAME
    (20) boolexp -> . BOOLVAL

    (               shift and go to state 16
    INUMBER         shift and go to state 17
    FNUMBER         shift and go to state 18
    NAME            shift and go to state 20
    BOOLVAL         shift and go to state 21

    expression                     shift and go to state 36
    boolexp                        shift and go to state 19

state 25

    (10) statement -> NAME = expression . ;
    (12) expression -> expression . + expression
    (13) expression -> expression . - expression
    (14) expression -> expression . * expression
    (15) expression -> expression . / expression
    (16) expression -> expression . ^ expression

    ;               shift and go to state 37
    +               shift and go to state 29
    -               shift and go to state 30
    *               shift and go to state 31
    /               shift and go to state 32
    ^               shift and go to state 33


state 26

    (6) statement -> FLOATDCL NAME ; .

    INTDCL          reduce using rule 6 (statement -> FLOATDCL NAME ; .)
    FLOATDCL        reduce using rule 6 (statement -> FLOATDCL NAME ; .)
    BOOLDCL         reduce using rule 6 (statement -> FLOATDCL NAME ; .)
    PRINT           reduce using rule 6 (statement -> FLOATDCL NAME ; .)
    IF              reduce using rule 6 (statement -> FLOATDCL NAME ; .)
    NAME            reduce using rule 6 (statement -> FLOATDCL NAME ; .)
    $end            reduce using rule 6 (statement -> FLOATDCL NAME ; .)
    }               reduce using rule 6 (statement -> FLOATDCL NAME ; .)


state 27

    (7) statement -> BOOLDCL NAME ; .

    INTDCL          reduce using rule 7 (statement -> BOOLDCL NAME ; .)
    FLOATDCL        reduce using rule 7 (statement -> BOOLDCL NAME ; .)
    BOOLDCL         reduce using rule 7 (statement -> BOOLDCL NAME ; .)
    PRINT           reduce using rule 7 (statement -> BOOLDCL NAME ; .)
    IF              reduce using rule 7 (statement -> BOOLDCL NAME ; .)
    NAME            reduce using rule 7 (statement -> BOOLDCL NAME ; .)
    $end            reduce using rule 7 (statement -> BOOLDCL NAME ; .)
    }               reduce using rule 7 (statement -> BOOLDCL NAME ; .)


state 28

    (8) statement -> PRINT expression ; .

    INTDCL          reduce using rule 8 (statement -> PRINT expression ; .)
    FLOATDCL        reduce using rule 8 (statement -> PRINT expression ; .)
    BOOLDCL         reduce using rule 8 (statement -> PRINT expression ; .)
    PRINT           reduce using rule 8 (statement -> PRINT expression ; .)
    IF              reduce using rule 8 (statement -> PRINT expression ; .)
    NAME            reduce using rule 8 (statement -> PRINT expression ; .)
    $end            reduce using rule 8 (statement -> PRINT expression ; .)
    }               reduce using rule 8 (statement -> PRINT expression ; .)


state 29

    (12) expression -> expression + . expression
    (11) expression -> . ( expression )
    (12) expression -> . expression + expression
    (13) expression -> . expression - expression
    (14) expression -> . expression * expression
    (15) expression -> . expression / expression
    (16) expression -> . expression ^ expression
    (17) expression -> . INUMBER
    (18) expression -> . FNUMBER
    (19) expression -> . boolexp
    (21) expression -> . NAME
    (20) boolexp -> . BOOLVAL

    (               shift and go to state 16
    INUMBER         shift and go to state 17
    FNUMBER         shift and go to state 18
    NAME            shift and go to state 20
    BOOLVAL         shift and go to state 21

    expression                     shift and go to state 38
    boolexp                        shift and go to state 19

state 30

    (13) expression -> expression - . expression
    (11) expression -> . ( expression )
    (12) expression -> . expression + expression
    (13) expression -> . expression - expression
    (14) expression -> . expression * expression
    (15) expression -> . expression / expression
    (16) expression -> . expression ^ expression
    (17) expression -> . INUMBER
    (18) expression -> . FNUMBER
    (19) expression -> . boolexp
    (21) expression -> . NAME
    (20) boolexp -> . BOOLVAL

    (               shift and go to state 16
    INUMBER         shift and go to state 17
    FNUMBER         shift and go to state 18
    NAME            shift and go to state 20
    BOOLVAL         shift and go to state 21

    expression                     shift and go to state 39
    boolexp                        shift and go to state 19

state 31

    (14) expression -> expression * . expression
    (11) expression -> . ( expression )
    (12) expression -> . expression + expression
    (13) expression -> . expression - expression
    (14) expression -> . expression * expression
    (15) expression -> . expression / expression
    (16) expression -> . expression ^ expression
    (17) expression -> . INUMBER
    (18) expression -> . FNUMBER
    (19) expression -> . boolexp
    (21) expression -> . NAME
    (20) boolexp -> . BOOLVAL

    (               shift and go to state 16
    INUMBER         shift and go to state 17
    FNUMBER         shift and go to state 18
    NAME            shift and go to state 20
    BOOLVAL         shift and go to state 21

    expression                     shift and go to state 40
    boolexp                        shift and go to state 19

state 32

    (15) expression -> expression / . expression
    (11) expression -> . ( expression )
    (12) expression -> . expression + expression
    (13) expression -> . expression - expression
    (14) expression -> . expression * expression
    (15) expression -> . expression / expression
    (16) expression -> . expression ^ expression
    (17) expression -> . INUMBER
    (18) expression -> . FNUMBER
    (19) expression -> . boolexp
    (21) expression -> . NAME
    (20) boolexp -> . BOOLVAL

    (               shift and go to state 16
    INUMBER         shift and go to state 17
    FNUMBER         shift and go to state 18
    NAME            shift and go to state 20
    BOOLVAL         shift and go to state 21

    expression                     shift and go to state 41
    boolexp                        shift and go to state 19

state 33

    (16) expression -> expression ^ . expression
    (11) expression -> . ( expression )
    (12) expression -> . expression + expression
    (13) expression -> . expression - expression
    (14) expression -> . expression * expression
    (15) expression -> . expression / expression
    (16) expression -> . expression ^ expression
    (17) expression -> . INUMBER
    (18) expression -> . FNUMBER
    (19) expression -> . boolexp
    (21) expression -> . NAME
    (20) boolexp -> . BOOLVAL

    (               shift and go to state 16
    INUMBER         shift and go to state 17
    FNUMBER         shift and go to state 18
    NAME            shift and go to state 20
    BOOLVAL         shift and go to state 21

    expression                     shift and go to state 42
    boolexp                        shift and go to state 19

state 34

    (11) expression -> ( expression . )
    (12) expression -> expression . + expression
    (13) expression -> expression . - expression
    (14) expression -> expression . * expression
    (15) expression -> expression . / expression
    (16) expression -> expression . ^ expression

    )               shift and go to state 43
    +               shift and go to state 29
    -               shift and go to state 30
    *               shift and go to state 31
    /               shift and go to state 32
    ^               shift and go to state 33


state 35

    (9) statement -> IF ( boolexp . ) { stmts }

    )               shift and go to state 44


state 36

    (5) statement -> INTDCL NAME = expression . ;
    (12) expression -> expression . + expression
    (13) expression -> expression . - expression
    (14) expression -> expression . * expression
    (15) expression -> expression . / expression
    (16) expression -> expression . ^ expression

    ;               shift and go to state 45
    +               shift and go to state 29
    -               shift and go to state 30
    *               shift and go to state 31
    /               shift and go to state 32
    ^               shift and go to state 33


state 37

    (10) statement -> NAME = expression ; .

    INTDCL          reduce using rule 10 (statement -> NAME = expression ; .)
    FLOATDCL        reduce using rule 10 (statement -> NAME = expression ; .)
    BOOLDCL         reduce using rule 10 (statement -> NAME = expression ; .)
    PRINT           reduce using rule 10 (statement -> NAME = expression ; .)
    IF              reduce using rule 10 (statement -> NAME = expression ; .)
    NAME            reduce using rule 10 (statement -> NAME = expression ; .)
    $end            reduce using rule 10 (statement -> NAME = expression ; .)
    }               reduce using rule 10 (statement -> NAME = expression ; .)


state 38

    (12) expression -> expression + expression .
    (12) expression -> expression . + expression
    (13) expression -> expression . - expression
    (14) expression -> expression . * expression
    (15) expression -> expression . / expression
    (16) expression -> expression . ^ expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
    ;               reduce using rule 12 (expression -> expression + expression .)
    )               reduce using rule 12 (expression -> expression + expression .)
    +               shift and go to state 29
    -               shift and go to state 30
    *               shift and go to state 31
    /               shift and go to state 32
    ^               shift and go to state 33

  ! +               [ reduce using rule 12 (expression -> expression + expression .) ]
  ! -               [ reduce using rule 12 (expression -> expression + expression .) ]
  ! *               [ reduce using rule 12 (expression -> expression + expression .) ]
  ! /               [ reduce using rule 12 (expression -> expression + expression .) ]
  ! ^               [ reduce using rule 12 (expression -> expression + expression .) ]


state 39

    (13) expression -> expression - expression .
    (12) expression -> expression . + expression
    (13) expression -> expression . - expression
    (14) expression -> expression . * expression
    (15) expression -> expression . / expression
    (16) expression -> expression . ^ expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
    ;               reduce using rule 13 (expression -> expression - expression .)
    )               reduce using rule 13 (expression -> expression - expression .)
    +               shift and go to state 29
    -               shift and go to state 30
    *               shift and go to state 31
    /               shift and go to state 32
    ^               shift and go to state 33

  ! +               [ reduce using rule 13 (expression -> expression - expression .) ]
  ! -               [ reduce using rule 13 (expression -> expression - expression .) ]
  ! *               [ reduce using rule 13 (expression -> expression - expression .) ]
  ! /               [ reduce using rule 13 (expression -> expression - expression .) ]
  ! ^               [ reduce using rule 13 (expression -> expression - expression .) ]


state 40

    (14) expression -> expression * expression .
    (12) expression -> expression . + expression
    (13) expression -> expression . - expression
    (14) expression -> expression . * expression
    (15) expression -> expression . / expression
    (16) expression -> expression . ^ expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
    ;               reduce using rule 14 (expression -> expression * expression .)
    )               reduce using rule 14 (expression -> expression * expression .)
    +               shift and go to state 29
    -               shift and go to state 30
    *               shift and go to state 31
    /               shift and go to state 32
    ^               shift and go to state 33

  ! +               [ reduce using rule 14 (expression -> expression * expression .) ]
  ! -               [ reduce using rule 14 (expression -> expression * expression .) ]
  ! *               [ reduce using rule 14 (expression -> expression * expression .) ]
  ! /               [ reduce using rule 14 (expression -> expression * expression .) ]
  ! ^               [ reduce using rule 14 (expression -> expression * expression .) ]


state 41

    (15) expression -> expression / expression .
    (12) expression -> expression . + expression
    (13) expression -> expression . - expression
    (14) expression -> expression . * expression
    (15) expression -> expression . / expression
    (16) expression -> expression . ^ expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
    ;               reduce using rule 15 (expression -> expression / expression .)
    )               reduce using rule 15 (expression -> expression / expression .)
    +               shift and go to state 29
    -               shift and go to state 30
    *               shift and go to state 31
    /               shift and go to state 32
    ^               shift and go to state 33

  ! +               [ reduce using rule 15 (expression -> expression / expression .) ]
  ! -               [ reduce using rule 15 (expression -> expression / expression .) ]
  ! *               [ reduce using rule 15 (expression -> expression / expression .) ]
  ! /               [ reduce using rule 15 (expression -> expression / expression .) ]
  ! ^               [ reduce using rule 15 (expression -> expression / expression .) ]


state 42

    (16) expression -> expression ^ expression .
    (12) expression -> expression . + expression
    (13) expression -> expression . - expression
    (14) expression -> expression . * expression
    (15) expression -> expression . / expression
    (16) expression -> expression . ^ expression

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
    ;               reduce using rule 16 (expression -> expression ^ expression .)
    )               reduce using rule 16 (expression -> expression ^ expression .)
    +               shift and go to state 29
    -               shift and go to state 30
    *               shift and go to state 31
    /               shift and go to state 32
    ^               shift and go to state 33

  ! +               [ reduce using rule 16 (expression -> expression ^ expression .) ]
  ! -               [ reduce using rule 16 (expression -> expression ^ expression .) ]
  ! *               [ reduce using rule 16 (expression -> expression ^ expression .) ]
  ! /               [ reduce using rule 16 (expression -> expression ^ expression .) ]
  ! ^               [ reduce using rule 16 (expression -> expression ^ expression .) ]


state 43

    (11) expression -> ( expression ) .

    ;               reduce using rule 11 (expression -> ( expression ) .)
    +               reduce using rule 11 (expression -> ( expression ) .)
    -               reduce using rule 11 (expression -> ( expression ) .)
    *               reduce using rule 11 (expression -> ( expression ) .)
    /               reduce using rule 11 (expression -> ( expression ) .)
    ^               reduce using rule 11 (expression -> ( expression ) .)
    )               reduce using rule 11 (expression -> ( expression ) .)


state 44

    (9) statement -> IF ( boolexp ) . { stmts }

    {               shift and go to state 46


state 45

    (5) statement -> INTDCL NAME = expression ; .

    INTDCL          reduce using rule 5 (statement -> INTDCL NAME = expression ; .)
    FLOATDCL        reduce using rule 5 (statement -> INTDCL NAME = expression ; .)
    BOOLDCL         reduce using rule 5 (statement -> INTDCL NAME = expression ; .)
    PRINT           reduce using rule 5 (statement -> INTDCL NAME = expression ; .)
    IF              reduce using rule 5 (statement -> INTDCL NAME = expression ; .)
    NAME            reduce using rule 5 (statement -> INTDCL NAME = expression ; .)
    $end            reduce using rule 5 (statement -> INTDCL NAME = expression ; .)
    }               reduce using rule 5 (statement -> INTDCL NAME = expression ; .)


state 46

    (9) statement -> IF ( boolexp ) { . stmts }
    (2) stmts -> . statement stmts
    (3) stmts -> . statement
    (4) statement -> . INTDCL NAME ;
    (5) statement -> . INTDCL NAME = expression ;
    (6) statement -> . FLOATDCL NAME ;
    (7) statement -> . BOOLDCL NAME ;
    (8) statement -> . PRINT expression ;
    (9) statement -> . IF ( boolexp ) { stmts }
    (10) statement -> . NAME = expression ;

    INTDCL          shift and go to state 4
    FLOATDCL        shift and go to state 6
    BOOLDCL         shift and go to state 7
    PRINT           shift and go to state 8
    IF              shift and go to state 9
    NAME            shift and go to state 5

    stmts                          shift and go to state 47
    statement                      shift and go to state 3

state 47

    (9) statement -> IF ( boolexp ) { stmts . }

    }               shift and go to state 48


state 48

    (9) statement -> IF ( boolexp ) { stmts } .

    INTDCL          reduce using rule 9 (statement -> IF ( boolexp ) { stmts } .)
    FLOATDCL        reduce using rule 9 (statement -> IF ( boolexp ) { stmts } .)
    BOOLDCL         reduce using rule 9 (statement -> IF ( boolexp ) { stmts } .)
    PRINT           reduce using rule 9 (statement -> IF ( boolexp ) { stmts } .)
    IF              reduce using rule 9 (statement -> IF ( boolexp ) { stmts } .)
    NAME            reduce using rule 9 (statement -> IF ( boolexp ) { stmts } .)
    $end            reduce using rule 9 (statement -> IF ( boolexp ) { stmts } .)
    }               reduce using rule 9 (statement -> IF ( boolexp ) { stmts } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for + in state 38 resolved as shift
WARNING: shift/reduce conflict for - in state 38 resolved as shift
WARNING: shift/reduce conflict for * in state 38 resolved as shift
WARNING: shift/reduce conflict for / in state 38 resolved as shift
WARNING: shift/reduce conflict for ^ in state 38 resolved as shift
WARNING: shift/reduce conflict for + in state 39 resolved as shift
WARNING: shift/reduce conflict for - in state 39 resolved as shift
WARNING: shift/reduce conflict for * in state 39 resolved as shift
WARNING: shift/reduce conflict for / in state 39 resolved as shift
WARNING: shift/reduce conflict for ^ in state 39 resolved as shift
WARNING: shift/reduce conflict for + in state 40 resolved as shift
WARNING: shift/reduce conflict for - in state 40 resolved as shift
WARNING: shift/reduce conflict for * in state 40 resolved as shift
WARNING: shift/reduce conflict for / in state 40 resolved as shift
WARNING: shift/reduce conflict for ^ in state 40 resolved as shift
WARNING: shift/reduce conflict for + in state 41 resolved as shift
WARNING: shift/reduce conflict for - in state 41 resolved as shift
WARNING: shift/reduce conflict for * in state 41 resolved as shift
WARNING: shift/reduce conflict for / in state 41 resolved as shift
WARNING: shift/reduce conflict for ^ in state 41 resolved as shift
WARNING: shift/reduce conflict for + in state 42 resolved as shift
WARNING: shift/reduce conflict for - in state 42 resolved as shift
WARNING: shift/reduce conflict for * in state 42 resolved as shift
WARNING: shift/reduce conflict for / in state 42 resolved as shift
WARNING: shift/reduce conflict for ^ in state 42 resolved as shift
